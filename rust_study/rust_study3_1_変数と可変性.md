The Rust Programming Language 日本語版
まえがき
導入

1. 事始め
   1.1. インストール
   1.2. Hello, World!
   1.3. Hello, Cargo!
2. 数当てゲームをプログラムする
3. 一般的なプログラミングの概念
   3.1. 変数と可変性
   3.2. データ型
   3.3. 関数
   3.4. コメント
   3.5. フロー制御
4. 所有権を理解する
   4.1. 所有権とは？
   4.2. 参照と借用
   4.3. スライス型
5. 構造体を使用して関係のあるデータを構造化する
   5.1. 構造体を定義し、インスタンス化する
   5.2. 構造体を使ったプログラム例
   5.3. メソッド記法
6. Enum とパターンマッチング
   6.1. Enum を定義する
   6.2. match フロー制御演算子
   6.3. if let で簡潔なフロー制御
7. 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する
   7.1. パッケージとクレート
   7.2. モジュールを定義して、スコープとプライバシーを制御する
   7.3. モジュールツリーの要素を示すためのパス
   7.4. use キーワードでパスをスコープに持ち込む
   7.5. モジュールを複数のファイルに分割する
8. 一般的なコレクション
   8.1. ベクタで一連の値を保持する
   8.2. 文字列で UTF-8 でエンコードされたテキストを保持する
   8.3. キーとそれに紐づいた値をハッシュマップに格納する
9. エラー処理
   9.1. panic!で回復不能なエラー
   9.2. Result で回復可能なエラー
   9.3. panic!すべきかするまいか
10. ジェネリック型、トレイト、ライフタイム
    10.1. ジェネリックなデータ型
    10.2. トレイト：共通の振る舞いを定義する
    10.3. ライフタイムで参照を検証する
11. 自動テストを書く
    11.1. テストの記述法
    11.2. テストの実行のされ方を制御する
    11.3. テストの体系化
12. 入出力プロジェクト：コマンドラインプログラムを構築する
    12.1. コマンドライン引数を受け付ける
    12.2. ファイルを読み込む
    12.3. リファクタリンクしてモジュール性とエラー処理を向上させる
    12.4. テスト駆動開発でライブラリの機能を開発する
    12.5. 環境変数を取り扱う
    12.6. 標準出力ではなく標準エラーにエラーメッセージを書き込む
13. 関数型言語の機能：イテレータとクロージャ
    13.1. クロージャ：環境をキャプチャできる匿名関数
    13.2. 一連の要素をイテレータで処理する
    13.3. 入出力プロジェクトを改善する
    13.4. パフォーマンス比較：ループ VS イテレータ
14. Cargo と Crates.io についてより詳しく
    14.1. リリースプロファイルでビルドをカスタマイズする
    14.2. Crates.io にクレートを公開する
    14.3. Cargo のワークスペース
    14.4. cargo install で Crates.io からバイナリをインストールする
    14.5. 独自のコマンドで Cargo を拡張する
15. スマートポインタ
    15.1. ヒープのデータを指す Box を使用する
    15.2. Deref トレイトでスマートポインタを普通の参照のように扱う
    15.3. Drop トレイトで片付け時にコードを走らせる
    15.4. Rc は、参照カウント方式のスマートポインタ
    15.5. RefCell と内部可変性パターン
    15.6. 循環参照は、メモリをリークすることもある
16. 恐れるな！並行性
    16.1. スレッドを使用してコードを同時に走らせる
    16.2. メッセージ受け渡しを使ってスレッド間でデータを転送する
    16.3. 状態共有並行性
    16.4. Sync と Send トレイトで拡張可能な並行性
17. Rust のオブジェクト指向プログラミング機能
    17.1. オブジェクト指向言語の特徴
    17.2. トレイトオブジェクトで異なる型の値を許容する
    17.3. オブジェクト指向デザインパターンを実装する
18. パターンとマッチング
    18.1. パターンが使用されることのある箇所全部
    18.2. 論駁可能性：パターンが合致しないかどうか
    18.3. パターン記法
19. 高度な機能
    19.1. Unsafe Rust
    19.2. 高度なトレイト
    19.3. 高度な型
    19.4. 高度な関数とクロージャ
    19.5. マクロ
20. 最後のプロジェクト：マルチスレッドの Web サーバを構築する
    20.1. シングルスレッドの Web サーバを構築する
    20.2. シングルスレッドサーバをマルチスレッド化する
    20.3. 正常なシャットダウンと片付け
21. 付録
    21.1. 付録 A：キーワード
    21.2. 付録 B：演算子と記号
    21.3. 付録 C：導出可能なトレイト
    21.4. 付録 D：便利な開発ツール
    21.5. 付録 E：Edition
    21.6. 付録 F：本の翻訳
    21.7. 付録 G：Rust の作られ方と“Nightly Rust”

The Rust Programming Language 日本語版
変数と可変性
第 2 章で触れた通り、変数は標準で不変になります。これは、 Rust が提供する安全性や簡便な並行性の利点を享受する形でコードを書くための選択の 1 つです。 ところが、まだ変数を可変にするという選択肢も残されています。 どのように、そしてなぜ Rust は不変性を推奨するのか、さらには、なぜそれとは違う道を選びたくなることがあるのか見ていきましょう。

変数が不変であると、値が一旦名前に束縛されたら、その値を変えることができません。 これを具体的に説明するために、projects ディレクトリに cargo new --bin variables コマンドを使って、 variables という名前のプロジェクトを生成しましょう。

それから、新規作成した variables ディレクトリで、src/main.rs ファイルを開き、 その中身を以下のコードに置き換えましょう。このコードはまだコンパイルできません:

ファイル名: src/main.rs

fn main() {
let x = 5;
println!("The value of x is: {}", x); // x の値は{}です
x = 6;
println!("The value of x is: {}", x);
}
これを保存し、cargo run コマンドでプログラムを走らせてください。次の出力に示されているようなエラーメッセージを受け取るはずです:

error[E0384]: cannot assgin twice immutable variable `x`
(不変変数`x`に 2 回代入できません)
--> src/main.rs:4:5
|
2 | let x = 5;
| - first assignment to `x`
| (`x`への最初の代入)
3 | println!("The value of x is: {}", x);
4 | x = 6;
| ^^^^^ cannot assign twice to immutable variable
この例では、コンパイラがプログラムに潜むエラーを見つけ出す手助けをしてくれることが示されています。 コンパイルエラーは、イライラすることもあるものですが、まだプログラムにしてほしいことを安全に行えていないだけということなのです; エラーが出るからといって、あなたがいいプログラマではないという意味ではありません！ 経験豊富な Rustacean でも、コンパイルエラーを出すことはあります。

このエラーは、エラーの原因が不変変数 x に 2 回代入できないであると示しています。不変な x という変数に別の値を代入しようとしたからです。

以前に不変と指定された値を変えようとした時に、コンパイルエラーが出るのは重要なことです。 なぜなら、この状況はまさしく、バグに繋がるからです。コードのある部分は、 値が変わることはないという前提のもとに処理を行い、別の部分がその値を変更していたら、 最初の部分が目論見通りに動いていない可能性があるのです。このようなバグの発生は、 事実(訳注:実際にプログラムを走らせた結果のことと思われる)の後には追いかけづらいものです。 特に第 2 のコード片が、値を時々しか変えない場合、尚更です。

Rust では、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保してくれます。 つまり、コードを読み書きする際に、どこでどうやって値が変化しているかを追いかける必要がなくなります。 故にコードを通して正しいことを確認するのが簡単になるのです。

しかし、可変性は時として非常に有益なこともあります。変数は、標準でのみ、不変です。つまり、 第 2 章のように変数名の前に mut キーワードを付けることで、可変にできるわけです。この値が変化できるようにするとともに、 mut により、未来の読者に対してコードの別の部分がこの変数の値を変える可能性を示すことで、その意図を汲ませることができるのです。

例として、src/main.rs ファイルを以下のように書き換えてください:

ファイル名: src/main.rs

fn main() {
let mut x = 5;
println!("The value of x is: {}", x);
x = 6;
println!("The value of x is: {}", x);
}
今、このプログラムを走らせると、以下のような出力が得られます:

\$ cargo run
Compiling variables v0.1.0 (file:///projects/variables)
Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
Running `target/debug/variables`
The value of x is: 5 (x の値は 5 です)
The value of x is: 6
mut キーワードが使われると、x が束縛している値を 5 から 6 に変更できます。 変数を可変にする方が、不変変数だけがあるよりも書きやすくなるので、変数を可変にしたくなることもあるでしょう。

考えるべきトレードオフはバグの予防以外にも、いくつかあります。例えば、大きなデータ構造を使う場合などです。 インスタンスを可変にして変更できるようにする方が、いちいちインスタンスをコピーして新しくメモリ割り当てされたインスタンスを返すよりも速くなります。 小規模なデータ構造なら、新規インスタンスを生成して、もっと関数型っぽいコードを書く方が通して考えやすくなるため、 低パフォーマンスは、その簡潔性を得るのに足りうるペナルティになるかもしれません。

変数と定数(constants)の違い
変数の値を変更できないようにするといえば、他の多くの言語も持っている別のプログラミング概念を思い浮かべるかもしれません: 定数です。不変変数のように、定数は名前に束縛され、変更することが叶わない値のことですが、 定数と変数の間にはいくつかの違いがあります。

まず、定数には mut キーワードは使えません: 定数は標準で不変であるだけでなく、常に不変なのです。

定数は let キーワードの代わりに、const キーワードで宣言し、値の型は必ず注釈しなければなりません。 型と型注釈については次のセクション、「データ型」で講義しますので、その詳細について気にする必要はありません。 ただ単に型は常に注釈しなければならないのだと思っていてください。

定数はどんなスコープでも定義できます。グローバルスコープも含めてです。なので、 いろんなところで使用される可能性のある値を定義するのに役に立ちます。

最後の違いは、定数は定数式にしかセットできないことです。関数呼び出し結果や、実行時に評価される値にはセットできません。

定数の名前が MAX_POINTS で、値が 100,000 にセットされた定数定義の例をご覧ください。(Rust の定数の命名規則は、 全て大文字でアンダースコアで単語区切りすることです):

const MAX_POINTS: u32 = 100_000;
定数は、プログラムが走る期間、定義されたスコープ内でずっと有効です。従って、 プログラムのいろんなところで使用される可能性のあるアプリケーション空間の値を定義するのに有益な選択肢になります。 例えば、ゲームでプレイヤーが取得可能なポイントの最高値や、光速度などですね。

プログラム中で使用されるハードコードされた値に対して、定数として名前付けすることは、 コードの将来的な管理者にとって値の意味を汲むのに役に立ちます。将来、ハードコードされた値を変える必要が出た時に、 たった 1 箇所を変更するだけで済むようにもしてくれます。

シャドーイング
第 2 章の数当てゲームのチュートリアル、「予想と秘密の数字を比較する」節で見たように、前に定義した変数と同じ名前の変数を新しく宣言でき、 新しい変数は、前の変数を覆い隠します。Rustacean はこれを最初の変数は、 2 番目の変数に覆い隠されたと言い、この変数を使用した際に、2 番目の変数の値が現れるということです。 以下のようにして、同じ変数名を用いて変数を覆い隠し、let キーワードの使用を繰り返します:

ファイル名: src/main.rs

fn main() {
let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);

}
このプログラムはまず、x を 5 という値に束縛します。それから let x =を繰り返すことで x を覆い隠し、 元の値に 1 を加えることになるので、x の値は 6 になります。 3 番目の let 文も x を覆い隠し、以前の値に 2 をかけることになるので、x の最終的な値は 12 になります。 このプログラムを走らせたら、以下のように出力するでしょう:

\$ cargo run
Compiling variables v0.1.0 (file:///projects/variables)
Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
Running `target/debug/variables`
The value of x is: 12
シャドーイングは、変数を mut にするのとは違います。なぜなら、let キーワードを使わずに、 誤ってこの変数に再代入を試みようものなら、コンパイルエラーが出るからです。let を使うことで、 値にちょっとした加工は行えますが、その加工が終わったら、変数は不変になるわけです。

mut と上書きのもう一つの違いは、再度 let キーワードを使用したら、実効的には新しい変数を生成していることになるので、 値の型を変えつつ、同じ変数名を使いまわせることです。例えば、 プログラムがユーザに何らかのテキストに対して空白文字を入力することで何個分のスペースを表示したいかを尋ねますが、 ただ、実際にはこの入力を数値として保持したいとしましょう:

let spaces = " ";
let spaces = spaces.len();
この文法要素は、容認されます。というのも、最初の spaces 変数は文字列型であり、2 番目の spaces 変数は、 たまたま最初の変数と同じ名前になったまっさらな変数のわけですが、数値型になるからです。故に、シャドーイングのおかげで、 異なる名前を思いつく必要がなくなるわけです。spaces_str と spaces_num などですね; 代わりに、 よりシンプルな spaces という名前を再利用できるわけです。一方で、この場合に mut を使おうとすると、 以下に示した通りですが、コンパイルエラーになるわけです:

let mut spaces = " ";
spaces = spaces.len();
変数の型を可変にすることは許されていないと言われているわけです:

error[E0308]: mismatched types (型が合いません)
--> src/main.rs:3:14
|
3 | spaces = spaces.len();
| ^^^^^^^^^^^^ expected &str, found usize
| (&str 型を予期しましたが、usize が見つかりました)
|
= note: expected type `&str`
found type `usize`
さあ、変数が動作する方法を見てきたので、今度は変数が取りうるデータ型について見ていきましょう。
