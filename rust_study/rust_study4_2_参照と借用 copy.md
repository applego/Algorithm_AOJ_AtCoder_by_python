The Rust Programming Language 日本語版
まえがき
導入

1. 事始め
   1.1. インストール
   1.2. Hello, World!
   1.3. Hello, Cargo!
2. 数当てゲームをプログラムする
3. 一般的なプログラミングの概念
   3.1. 変数と可変性
   3.2. データ型
   3.3. 関数
   3.4. コメント
   3.5. フロー制御
4. 所有権を理解する
   4.1. 所有権とは？
   4.2. 参照と借用
   4.3. スライス型
5. 構造体を使用して関係のあるデータを構造化する
   5.1. 構造体を定義し、インスタンス化する
   5.2. 構造体を使ったプログラム例
   5.3. メソッド記法
6. Enum とパターンマッチング
   6.1. Enum を定義する
   6.2. match フロー制御演算子
   6.3. if let で簡潔なフロー制御
7. 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する
   7.1. パッケージとクレート
   7.2. モジュールを定義して、スコープとプライバシーを制御する
   7.3. モジュールツリーの要素を示すためのパス
   7.4. use キーワードでパスをスコープに持ち込む
   7.5. モジュールを複数のファイルに分割する
8. 一般的なコレクション
   8.1. ベクタで一連の値を保持する
   8.2. 文字列で UTF-8 でエンコードされたテキストを保持する
   8.3. キーとそれに紐づいた値をハッシュマップに格納する
9. エラー処理
   9.1. panic!で回復不能なエラー
   9.2. Result で回復可能なエラー
   9.3. panic!すべきかするまいか
10. ジェネリック型、トレイト、ライフタイム
    10.1. ジェネリックなデータ型
    10.2. トレイト：共通の振る舞いを定義する
    10.3. ライフタイムで参照を検証する
11. 自動テストを書く
    11.1. テストの記述法
    11.2. テストの実行のされ方を制御する
    11.3. テストの体系化
12. 入出力プロジェクト：コマンドラインプログラムを構築する
    12.1. コマンドライン引数を受け付ける
    12.2. ファイルを読み込む
    12.3. リファクタリンクしてモジュール性とエラー処理を向上させる
    12.4. テスト駆動開発でライブラリの機能を開発する
    12.5. 環境変数を取り扱う
    12.6. 標準出力ではなく標準エラーにエラーメッセージを書き込む
13. 関数型言語の機能：イテレータとクロージャ
    13.1. クロージャ：環境をキャプチャできる匿名関数
    13.2. 一連の要素をイテレータで処理する
    13.3. 入出力プロジェクトを改善する
    13.4. パフォーマンス比較：ループ VS イテレータ
14. Cargo と Crates.io についてより詳しく
    14.1. リリースプロファイルでビルドをカスタマイズする
    14.2. Crates.io にクレートを公開する
    14.3. Cargo のワークスペース
    14.4. cargo install で Crates.io からバイナリをインストールする
    14.5. 独自のコマンドで Cargo を拡張する
15. スマートポインタ
    15.1. ヒープのデータを指す Box を使用する
    15.2. Deref トレイトでスマートポインタを普通の参照のように扱う
    15.3. Drop トレイトで片付け時にコードを走らせる
    15.4. Rc は、参照カウント方式のスマートポインタ
    15.5. RefCell と内部可変性パターン
    15.6. 循環参照は、メモリをリークすることもある
16. 恐れるな！並行性
    16.1. スレッドを使用してコードを同時に走らせる
    16.2. メッセージ受け渡しを使ってスレッド間でデータを転送する
    16.3. 状態共有並行性
    16.4. Sync と Send トレイトで拡張可能な並行性
17. Rust のオブジェクト指向プログラミング機能
    17.1. オブジェクト指向言語の特徴
    17.2. トレイトオブジェクトで異なる型の値を許容する
    17.3. オブジェクト指向デザインパターンを実装する
18. パターンとマッチング
    18.1. パターンが使用されることのある箇所全部
    18.2. 論駁可能性：パターンが合致しないかどうか
    18.3. パターン記法
19. 高度な機能
    19.1. Unsafe Rust
    19.2. 高度なトレイト
    19.3. 高度な型
    19.4. 高度な関数とクロージャ
    19.5. マクロ
20. 最後のプロジェクト：マルチスレッドの Web サーバを構築する
    20.1. シングルスレッドの Web サーバを構築する
    20.2. シングルスレッドサーバをマルチスレッド化する
    20.3. 正常なシャットダウンと片付け
21. 付録
    21.1. 付録 A：キーワード
    21.2. 付録 B：演算子と記号
    21.3. 付録 C：導出可能なトレイト
    21.4. 付録 D：便利な開発ツール
    21.5. 付録 E：Edition
    21.6. 付録 F：本の翻訳
    21.7. 付録 G：Rust の作られ方と“Nightly Rust”

The Rust Programming Language 日本語版
スライス型
所有権のない別のデータ型は、スライスです。スライスにより、コレクション全体というより、 その内の一連の要素を参照することができます。

ここに小さなプログラミング問題があります: 文字列を受け取って、その文字列中の最初の単語を返す関数を書いてください。 関数が文字列中に空白を見つけなかったら、文字列全体が一つの単語に違いないので、文字列全体が返されるべきです。

この関数のシグニチャについて考えてみましょう:

fn first_word(s: &String) -> ?
この関数、first_word は引数に&String をとります。所有権はいらないので、これで十分です。 ですが、何を返すべきでしょうか？文字列の一部について語る方法が全くありません。しかし、 単語の終端の添え字を返すことができますね。リスト 4-7 に示したように、その方法を試してみましょう。

ファイル名: src/main.rs

fn first_word(s: &String) -> usize {
let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()

}
リスト 4-7: String 引数へのバイト数で表された添え字を返す first_word 関数

String の値を要素ごとに見て、空白かどうかを確かめる必要があるので、 as_bytes メソッドを使って、String オブジェクトをバイト配列に変換しています。

let bytes = s.as_bytes();
次に、そのバイト配列に対して、iter メソッドを使用してイテレータを生成しています:

for (i, &item) in bytes.iter().enumerate() {
イテレータについて詳しくは、第 13 章で議論します。今は、iter は、コレクション内の各要素を返すメソッドであること、 enumerate が iter の結果を包んで、代わりにタプルの一部として各要素を返すことを知っておいてください。 enumerate から返ってくるタプルの第 1 要素は、添え字であり、2 番目の要素は、(コレクションの)要素への参照になります。 これは、手動で添え字を計算するよりも少しだけ便利です。

enumerate メソッドがタプルを返すので、Rust のあらゆる場所同様、パターンを使って、そのタプルを分配できます。 従って、for ループ内で、タプルの添え字に対する i とタプルの 1 バイトに対応する&item を含むパターンを指定しています。 .iter().enumerate()から要素への参照を取得するので、パターンに&を使っています。

for ループ内で、バイトリテラル表記を使用して空白を表すバイトを検索しています。空白が見つかったら、その位置を返します。 それ以外の場合、s.len()を使って文字列の長さを返します。

    if item == b' ' {
        return i;
    }

}

s.len()
さて、文字列内の最初の単語の終端の添え字を見つけ出せるようになりましたが、問題があります。 usize 型を単独で返していますが、これは&String の文脈でのみ意味を持つ数値です。 言い換えると、String から切り離された値なので、将来的にも有効である保証がないのです。 リスト 4-7 の first_word 関数を使用するリスト 4-8 のプログラムを考えてください。

ファイル名: src/main.rs

fn main() {
let mut s = String::from("hello world");

    let word = first_word(&s); // wordの中身は、値5になる

    s.clear(); // Stringを空にする。つまり、""と等しくする

    // wordはまだ値5を保持しているが、もうこの値を有効に使用できる文字列は存在しない。
    // wordは完全に無効なのだ！

}
リスト 4-8: first_word 関数の呼び出し結果を保持し、String の中身を変更する

このプログラムは何のエラーもなくコンパイルが通り、word を s.clear()の呼び出し後に使用しても、 コンパイルが通ります。word は s の状態に全く関連づけられていないので、その中身はまだ値 5 のままです。 その値 5 を変数 s に使用し、最初の単語を取り出そうとすることはできますが、これはバグでしょう。 というのも、s の中身は、5 を word に保存してから変わってしまったからです。

word 内の添え字が s に格納されたデータと同期されなくなるのを心配することは、面倒ですし間違いになりやすいです！ これらの添え字の管理は、second_word 関数を書いたら、さらに難しくなります。 そのシグニチャは以下のようになるはずです:

fn second_word(s: &String) -> (usize, usize) {
今、私たちは開始と終端の添え字を追うようになりました。特定の状態のデータから計算されたけど、 その状態に全く紐付かない値が増えました。いつの間にか変わってしまうので、同期を取る必要のある、関連性のない変数が 3 つになってしまいました。

運のいいことに、Rust にはこの問題への解決策が用意されています: 文字列スライスです。

文字列スライス
文字列スライスとは、String の一部への参照で、こんな見た目をしています:

let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
これは、String 全体への参照を取ることに似ていますが、余計な[0..5]という部分が付いています。 String 全体への参照というよりも、String の一部への参照です。開始..終点という記法は、開始から始まり、 終点未満までずっと続く範囲です。

[starting_index..ending_index]と指定することで、角かっこに範囲を使い、スライスを生成できます。 ここで、starting_index はスライスの最初の位置、ending_index はスライスの終端位置よりも、 1 大きくなります。内部的には、スライスデータ構造は、開始地点とスライスの長さを保持しており、 スライスの長さは ending_index から starting_index を引いたものに対応します。以上より、 let world = &s[6..11];の場合には、world は s の 7 バイト目へのポインタと 5 という長さを保持するスライスになるでしょう。

図 4-6 は、これを図解しています。

文字列 s の 6 バイト目へのポインタと長さ 5 を保持する world
図 4-6: String オブジェクトの一部を参照する文字列スライス

Rust の..という範囲記法で、最初の番号(ゼロ)から始めたければ、2 連ピリオドの前に値を書かなければいいのです。 換言すれば、これらは等価です:

let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
同様の意味で、String の最後のバイトをスライスが含むのならば、末尾の数値を書かなければいいのです。 つまり、これらは等価になります:

let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
さらに、両方の値を省略すると、文字列全体のスライスを得られます。故に、これらは等価です:

let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
注釈: 文字列スライスの範囲添え字は、有効な UTF-8 文字境界に置かなければなりません。 マルチバイト文字の真ん中で文字列スライスを生成しようとしたら、エラーでプログラムは落ちるでしょう。 文字列スライスを導入する目的で、この節では ASCII のみを想定しています; UTF-8 に関するより徹底した議論は、 第 8 章の「文字列で UTF-8 エンコードされたテキストを格納する」節で行います。

これら全ての情報を心に留めて、first_word を書き直してスライスを返すようにしましょう。 文字列スライスを意味する型は、&str と記述します:

ファイル名: src/main.rs

fn first_word(s: &String) -> &str {
let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]

}
リスト 4-7 で取った手段と同じ方法で単語の終端添え字を取得しています。つまり、最初の空白を探すことです。 空白を発見したら、文字列の最初を開始地点、空白の添え字を終了地点として使用して文字列スライスを返しています。

これで、first_word を呼び出すと、元のデータに紐付けられた単独の値を得られるようになりました。 この値は、スライスの開始地点への参照とスライス中の要素数から構成されています。

second_word 関数についても、スライスを返すことでうまくいくでしょう:

fn second_word(s: &String) -> &str {
これで、ずっと混乱しにくい素直な API になりました。なぜなら、String への参照が有効なままであることをコンパイラが、 保証してくれるからです。最初の単語の終端添え字を得た時に、 文字列を空っぽにして先ほどの添え字が無効になってしまったリスト 4-8 のプログラムのバグを覚えていますか？ そのコードは、論理的に正しくないのですが、即座にエラーにはなりませんでした。問題は後になってから発生し、 それは空の文字列に対して、最初の単語の添え字を使用し続けようとした時でした。スライスならこんなバグはあり得ず、 コードに問題があるなら、もっと迅速に判明します。スライスバージョンの first_word を使用すると、 コンパイルエラーが発生します:

ファイル名: src/main.rs

fn main() {
let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!    (エラー！)

    println!("the first word is: {}", word);

}
こちらがコンパイルエラーです:

\$ cargo run
Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
(エラー: 不変として借用されているので、`s`を可変で借用できません)
--> src/main.rs:18:5
|
16 | let word = first_word(&s);
| -- immutable borrow occurs here (不変借用はここで発生しています)
17 |
18 | s.clear(); // error! (エラー！)
| ^^^^^^^^^ mutable borrow occurs here (可変借用はここで発生しています)
19 |
20 | println!("the first word is: {}", word);
| ---- immutable borrow later used here
(不変借用はその後ここで使われています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
借用規則から、何かへの不変な参照がある時、さらに可変な参照を得ることはできないことを思い出してください。 clear は String を切り詰める必要があるので、可変な参照を得ようとして失敗しているわけです。 Rust のおかげで API が使いやすくなるだけでなく、ある種のエラー全てを完全にコンパイル時に排除してくれるのです！

文字列リテラルはスライスである
文字列は、バイナリに埋め込まれると話したことを思い出してください。今やスライスのことを知ったので、 文字列リテラルを正しく理解することができます。

let s = "Hello, world!";
ここでの s の型は、&str です: バイナリのその特定の位置を指すスライスです。 これは、文字列が不変である理由にもなっています。要するに、&str は不変な参照なのです。

引数としての文字列スライス
リテラルや String 値のスライスを得ることができると知ると、first_word に対して、もう一つ改善点を見出すことができます。 シグニチャです:

fn first_word(s: &String) -> &str {
もっと経験を積んだ Rustacean なら、代わりにリスト 4-9 のようなシグニチャを書くでしょう。というのも、こうすると、 同じ関数を String 値と&str 値両方に使えるようになるからです。

fn first_word(s: &str) -> &str {
リスト 4-9: s 引数の型に文字列スライスを使用して first_word 関数を改善する

もし、文字列スライスがあるなら、それを直接渡せます。String があるなら、 その String 全体のスライスを渡せます。String への参照の代わりに文字列スライスを取るよう関数を定義すると、 何も機能を失うことなく API をより一般的で有益なものにできるのです。

Filename: src/main.rs

fn main() {
let my_string = String::from("hello world");

    // first_wordは`String`のスライスに対して機能する
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_wordは文字列リテラルのスライスに対して機能する
    let word = first_word(&my_string_literal[..]);

    // 文字列リテラルは、すでに文字列スライス*な*ので、
    // スライス記法なしでも機能するのだ！
    let word = first_word(my_string_literal);

}
他のスライス
文字列リテラルは、ご想像通り、文字列に特化したものです。ですが、もっと一般的なスライス型も存在します。 この配列を考えてください:

let a = [1, 2, 3, 4, 5];
文字列の一部を参照したくなる可能性があるのと同様、配列の一部を参照したくなる可能性もあります。 以下のようにすれば、参照することができます:

let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
このスライスは、&[i32]という型になります。これも文字列スライスと同じように動作します。 つまり、最初の要素への参照と長さを保持することです。他のすべての種類のコレクションに対して、 この種のスライスは使用するでしょう。これらのコレクションについて詳しくは、 第 8 章でベクタについて話すときに議論します。

まとめ
所有権、借用、スライスの概念は、コンパイル時に Rust プログラムにおいて、メモリ安全性を保証します。 Rust 言語も他のシステムプログラミング言語と同じように、メモリの使用法について制御させてくれるわけですが、 所有者がスコープを抜けたときにデータの所有者に自動的にデータを片付けさせることは、この制御を得るために、 余計なコードを書いてデバッグする必要がないことを意味します。

所有権は、Rust の他のいろんな部分が動作する方法に影響を与えるので、これ以降もこれらの概念についてさらに語っていく予定です。 第 5 章に移って、struct でデータをグループ化することについて見ていきましょう。
