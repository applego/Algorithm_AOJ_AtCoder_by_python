The Rust Programming Language 日本語版
まえがき
導入

The Rust Programming Language 日本語版
スライス型
所有権のない別のデータ型は、スライスです。スライスにより、コレクション全体というより、 その内の一連の要素を参照することができます。

ここに小さなプログラミング問題があります: 文字列を受け取って、その文字列中の最初の単語を返す関数を書いてください。 関数が文字列中に空白を見つけなかったら、文字列全体が一つの単語に違いないので、文字列全体が返されるべきです。

この関数のシグニチャについて考えてみましょう:

fn first_word(s: &String) -> ?
この関数、first_word は引数に&String をとります。所有権はいらないので、これで十分です。 ですが、何を返すべきでしょうか？文字列の一部について語る方法が全くありません。しかし、 単語の終端の添え字を返すことができますね。リスト 4-7 に示したように、その方法を試してみましょう。

ファイル名: src/main.rs

fn first_word(s: &String) -> usize {
let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()

}
リスト 4-7: String 引数へのバイト数で表された添え字を返す first_word 関数

String の値を要素ごとに見て、空白かどうかを確かめる必要があるので、 as_bytes メソッドを使って、String オブジェクトをバイト配列に変換しています。

let bytes = s.as_bytes();
次に、そのバイト配列に対して、iter メソッドを使用してイテレータを生成しています:

for (i, &item) in bytes.iter().enumerate() {
イテレータについて詳しくは、第 13 章で議論します。今は、iter は、コレクション内の各要素を返すメソッドであること、 enumerate が iter の結果を包んで、代わりにタプルの一部として各要素を返すことを知っておいてください。 enumerate から返ってくるタプルの第 1 要素は、添え字であり、2 番目の要素は、(コレクションの)要素への参照になります。 これは、手動で添え字を計算するよりも少しだけ便利です。

enumerate メソッドがタプルを返すので、Rust のあらゆる場所同様、パターンを使って、そのタプルを分配できます。 従って、for ループ内で、タプルの添え字に対する i とタプルの 1 バイトに対応する&item を含むパターンを指定しています。 .iter().enumerate()から要素への参照を取得するので、パターンに&を使っています。

for ループ内で、バイトリテラル表記を使用して空白を表すバイトを検索しています。空白が見つかったら、その位置を返します。 それ以外の場合、s.len()を使って文字列の長さを返します。

    if item == b' ' {
        return i;
    }

}

s.len()
さて、文字列内の最初の単語の終端の添え字を見つけ出せるようになりましたが、問題があります。 usize 型を単独で返していますが、これは&String の文脈でのみ意味を持つ数値です。 言い換えると、String から切り離された値なので、将来的にも有効である保証がないのです。 リスト 4-7 の first_word 関数を使用するリスト 4-8 のプログラムを考えてください。

ファイル名: src/main.rs

fn main() {
let mut s = String::from("hello world");

    let word = first_word(&s); // wordの中身は、値5になる

    s.clear(); // Stringを空にする。つまり、""と等しくする

    // wordはまだ値5を保持しているが、もうこの値を有効に使用できる文字列は存在しない。
    // wordは完全に無効なのだ！

}
リスト 4-8: first_word 関数の呼び出し結果を保持し、String の中身を変更する

このプログラムは何のエラーもなくコンパイルが通り、word を s.clear()の呼び出し後に使用しても、 コンパイルが通ります。word は s の状態に全く関連づけられていないので、その中身はまだ値 5 のままです。 その値 5 を変数 s に使用し、最初の単語を取り出そうとすることはできますが、これはバグでしょう。 というのも、s の中身は、5 を word に保存してから変わってしまったからです。

word 内の添え字が s に格納されたデータと同期されなくなるのを心配することは、面倒ですし間違いになりやすいです！ これらの添え字の管理は、second_word 関数を書いたら、さらに難しくなります。 そのシグニチャは以下のようになるはずです:

fn second_word(s: &String) -> (usize, usize) {
今、私たちは開始と終端の添え字を追うようになりました。特定の状態のデータから計算されたけど、 その状態に全く紐付かない値が増えました。いつの間にか変わってしまうので、同期を取る必要のある、関連性のない変数が 3 つになってしまいました。

運のいいことに、Rust にはこの問題への解決策が用意されています: 文字列スライスです。

文字列スライス
文字列スライスとは、String の一部への参照で、こんな見た目をしています:

let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
これは、String 全体への参照を取ることに似ていますが、余計な[0..5]という部分が付いています。 String 全体への参照というよりも、String の一部への参照です。開始..終点という記法は、開始から始まり、 終点未満までずっと続く範囲です。

[starting_index..ending_index]と指定することで、角かっこに範囲を使い、スライスを生成できます。 ここで、starting_index はスライスの最初の位置、ending_index はスライスの終端位置よりも、 1 大きくなります。内部的には、スライスデータ構造は、開始地点とスライスの長さを保持しており、 スライスの長さは ending_index から starting_index を引いたものに対応します。以上より、 let world = &s[6..11];の場合には、world は s の 7 バイト目へのポインタと 5 という長さを保持するスライスになるでしょう。

図 4-6 は、これを図解しています。

文字列 s の 6 バイト目へのポインタと長さ 5 を保持する world
図 4-6: String オブジェクトの一部を参照する文字列スライス

Rust の..という範囲記法で、最初の番号(ゼロ)から始めたければ、2 連ピリオドの前に値を書かなければいいのです。 換言すれば、これらは等価です:

let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
同様の意味で、String の最後のバイトをスライスが含むのならば、末尾の数値を書かなければいいのです。 つまり、これらは等価になります:

let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
さらに、両方の値を省略すると、文字列全体のスライスを得られます。故に、これらは等価です:

let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
注釈: 文字列スライスの範囲添え字は、有効な UTF-8 文字境界に置かなければなりません。 マルチバイト文字の真ん中で文字列スライスを生成しようとしたら、エラーでプログラムは落ちるでしょう。 文字列スライスを導入する目的で、この節では ASCII のみを想定しています; UTF-8 に関するより徹底した議論は、 第 8 章の「文字列で UTF-8 エンコードされたテキストを格納する」節で行います。

これら全ての情報を心に留めて、first_word を書き直してスライスを返すようにしましょう。 文字列スライスを意味する型は、&str と記述します:

ファイル名: src/main.rs

fn first_word(s: &String) -> &str {
let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]

}
リスト 4-7 で取った手段と同じ方法で単語の終端添え字を取得しています。つまり、最初の空白を探すことです。 空白を発見したら、文字列の最初を開始地点、空白の添え字を終了地点として使用して文字列スライスを返しています。

これで、first_word を呼び出すと、元のデータに紐付けられた単独の値を得られるようになりました。 この値は、スライスの開始地点への参照とスライス中の要素数から構成されています。

second_word 関数についても、スライスを返すことでうまくいくでしょう:

fn second_word(s: &String) -> &str {
これで、ずっと混乱しにくい素直な API になりました。なぜなら、String への参照が有効なままであることをコンパイラが、 保証してくれるからです。最初の単語の終端添え字を得た時に、 文字列を空っぽにして先ほどの添え字が無効になってしまったリスト 4-8 のプログラムのバグを覚えていますか？ そのコードは、論理的に正しくないのですが、即座にエラーにはなりませんでした。問題は後になってから発生し、 それは空の文字列に対して、最初の単語の添え字を使用し続けようとした時でした。スライスならこんなバグはあり得ず、 コードに問題があるなら、もっと迅速に判明します。スライスバージョンの first_word を使用すると、 コンパイルエラーが発生します:

ファイル名: src/main.rs

fn main() {
let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!    (エラー！)

    println!("the first word is: {}", word);

}
こちらがコンパイルエラーです:

\$ cargo run
Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
(エラー: 不変として借用されているので、`s`を可変で借用できません)
--> src/main.rs:18:5
|
16 | let word = first_word(&s);
| -- immutable borrow occurs here (不変借用はここで発生しています)
17 |
18 | s.clear(); // error! (エラー！)
| ^^^^^^^^^ mutable borrow occurs here (可変借用はここで発生しています)
19 |
20 | println!("the first word is: {}", word);
| ---- immutable borrow later used here
(不変借用はその後ここで使われています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
借用規則から、何かへの不変な参照がある時、さらに可変な参照を得ることはできないことを思い出してください。 clear は String を切り詰める必要があるので、可変な参照を得ようとして失敗しているわけです。 Rust のおかげで API が使いやすくなるだけでなく、ある種のエラー全てを完全にコンパイル時に排除してくれるのです！

文字列リテラルはスライスである
文字列は、バイナリに埋め込まれると話したことを思い出してください。今やスライスのことを知ったので、 文字列リテラルを正しく理解することができます。

let s = "Hello, world!";
ここでの s の型は、&str です: バイナリのその特定の位置を指すスライスです。 これは、文字列が不変である理由にもなっています。要するに、&str は不変な参照なのです。

引数としての文字列スライス
リテラルや String 値のスライスを得ることができると知ると、first_word に対して、もう一つ改善点を見出すことができます。 シグニチャです:

fn first_word(s: &String) -> &str {
もっと経験を積んだ Rustacean なら、代わりにリスト 4-9 のようなシグニチャを書くでしょう。というのも、こうすると、 同じ関数を String 値と&str 値両方に使えるようになるからです。

fn first_word(s: &str) -> &str {
リスト 4-9: s 引数の型に文字列スライスを使用して first_word 関数を改善する

もし、文字列スライスがあるなら、それを直接渡せます。String があるなら、 その String 全体のスライスを渡せます。String への参照の代わりに文字列スライスを取るよう関数を定義すると、 何も機能を失うことなく API をより一般的で有益なものにできるのです。

Filename: src/main.rs

fn main() {
let my_string = String::from("hello world");

    // first_wordは`String`のスライスに対して機能する
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_wordは文字列リテラルのスライスに対して機能する
    let word = first_word(&my_string_literal[..]);

    // 文字列リテラルは、すでに文字列スライス*な*ので、
    // スライス記法なしでも機能するのだ！
    let word = first_word(my_string_literal);

}
他のスライス
文字列リテラルは、ご想像通り、文字列に特化したものです。ですが、もっと一般的なスライス型も存在します。 この配列を考えてください:

let a = [1, 2, 3, 4, 5];
文字列の一部を参照したくなる可能性があるのと同様、配列の一部を参照したくなる可能性もあります。 以下のようにすれば、参照することができます:

let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
このスライスは、&[i32]という型になります。これも文字列スライスと同じように動作します。 つまり、最初の要素への参照と長さを保持することです。他のすべての種類のコレクションに対して、 この種のスライスは使用するでしょう。これらのコレクションについて詳しくは、 第 8 章でベクタについて話すときに議論します。

まとめ
所有権、借用、スライスの概念は、コンパイル時に Rust プログラムにおいて、メモリ安全性を保証します。 Rust 言語も他のシステムプログラミング言語と同じように、メモリの使用法について制御させてくれるわけですが、 所有者がスコープを抜けたときにデータの所有者に自動的にデータを片付けさせることは、この制御を得るために、 余計なコードを書いてデバッグする必要がないことを意味します。

所有権は、Rust の他のいろんな部分が動作する方法に影響を与えるので、これ以降もこれらの概念についてさらに語っていく予定です。 第 5 章に移って、struct でデータをグループ化することについて見ていきましょう。
