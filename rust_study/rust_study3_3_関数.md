The Rust Programming Language 日本語版
まえがき
導入

1. 事始め
   1.1. インストール
   1.2. Hello, World!
   1.3. Hello, Cargo!
2. 数当てゲームをプログラムする
3. 一般的なプログラミングの概念
   3.1. 変数と可変性
   3.2. データ型
   3.3. 関数
   3.4. コメント
   3.5. フロー制御
4. 所有権を理解する
   4.1. 所有権とは？
   4.2. 参照と借用
   4.3. スライス型
5. 構造体を使用して関係のあるデータを構造化する
   5.1. 構造体を定義し、インスタンス化する
   5.2. 構造体を使ったプログラム例
   5.3. メソッド記法
6. Enum とパターンマッチング
   6.1. Enum を定義する
   6.2. match フロー制御演算子
   6.3. if let で簡潔なフロー制御
7. 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する
   7.1. パッケージとクレート
   7.2. モジュールを定義して、スコープとプライバシーを制御する
   7.3. モジュールツリーの要素を示すためのパス
   7.4. use キーワードでパスをスコープに持ち込む
   7.5. モジュールを複数のファイルに分割する
8. 一般的なコレクション
   8.1. ベクタで一連の値を保持する
   8.2. 文字列で UTF-8 でエンコードされたテキストを保持する
   8.3. キーとそれに紐づいた値をハッシュマップに格納する
9. エラー処理
   9.1. panic!で回復不能なエラー
   9.2. Result で回復可能なエラー
   9.3. panic!すべきかするまいか
10. ジェネリック型、トレイト、ライフタイム
    10.1. ジェネリックなデータ型
    10.2. トレイト：共通の振る舞いを定義する
    10.3. ライフタイムで参照を検証する
11. 自動テストを書く
    11.1. テストの記述法
    11.2. テストの実行のされ方を制御する
    11.3. テストの体系化
12. 入出力プロジェクト：コマンドラインプログラムを構築する
    12.1. コマンドライン引数を受け付ける
    12.2. ファイルを読み込む
    12.3. リファクタリンクしてモジュール性とエラー処理を向上させる
    12.4. テスト駆動開発でライブラリの機能を開発する
    12.5. 環境変数を取り扱う
    12.6. 標準出力ではなく標準エラーにエラーメッセージを書き込む
13. 関数型言語の機能：イテレータとクロージャ
    13.1. クロージャ：環境をキャプチャできる匿名関数
    13.2. 一連の要素をイテレータで処理する
    13.3. 入出力プロジェクトを改善する
    13.4. パフォーマンス比較：ループ VS イテレータ
14. Cargo と Crates.io についてより詳しく
    14.1. リリースプロファイルでビルドをカスタマイズする
    14.2. Crates.io にクレートを公開する
    14.3. Cargo のワークスペース
    14.4. cargo install で Crates.io からバイナリをインストールする
    14.5. 独自のコマンドで Cargo を拡張する
15. スマートポインタ
    15.1. ヒープのデータを指す Box を使用する
    15.2. Deref トレイトでスマートポインタを普通の参照のように扱う
    15.3. Drop トレイトで片付け時にコードを走らせる
    15.4. Rc は、参照カウント方式のスマートポインタ
    15.5. RefCell と内部可変性パターン
    15.6. 循環参照は、メモリをリークすることもある
16. 恐れるな！並行性
    16.1. スレッドを使用してコードを同時に走らせる
    16.2. メッセージ受け渡しを使ってスレッド間でデータを転送する
    16.3. 状態共有並行性
    16.4. Sync と Send トレイトで拡張可能な並行性
17. Rust のオブジェクト指向プログラミング機能
    17.1. オブジェクト指向言語の特徴
    17.2. トレイトオブジェクトで異なる型の値を許容する
    17.3. オブジェクト指向デザインパターンを実装する
18. パターンとマッチング
    18.1. パターンが使用されることのある箇所全部
    18.2. 論駁可能性：パターンが合致しないかどうか
    18.3. パターン記法
19. 高度な機能
    19.1. Unsafe Rust
    19.2. 高度なトレイト
    19.3. 高度な型
    19.4. 高度な関数とクロージャ
    19.5. マクロ
20. 最後のプロジェクト：マルチスレッドの Web サーバを構築する
    20.1. シングルスレッドの Web サーバを構築する
    20.2. シングルスレッドサーバをマルチスレッド化する
    20.3. 正常なシャットダウンと片付け
21. 付録
    21.1. 付録 A：キーワード
    21.2. 付録 B：演算子と記号
    21.3. 付録 C：導出可能なトレイト
    21.4. 付録 D：便利な開発ツール
    21.5. 付録 E：Edition
    21.6. 付録 F：本の翻訳
    21.7. 付録 G：Rust の作られ方と“Nightly Rust”

The Rust Programming Language 日本語版
関数
関数は、Rust のコードにおいてよく見かける存在です。既に、言語において最も重要な関数のうちの一つを目撃していますね: そう、main 関数です。これは、多くのプログラムのエントリーポイント(訳注: プログラム実行時に最初に走る関数のこと)になります。 fn キーワードもすでに見かけましたね。これによって新しい関数を宣言することができます。

Rust の関数と変数の命名規則は、スネークケース(訳注: some_variable のような命名規則)を使うのが慣例です。 スネークケースとは、全文字を小文字にし、単語区切りにアンダースコアを使うことです。 以下のプログラムで、サンプルの関数定義をご覧ください:

ファイル名: src/main.rs

fn main() {
println!("Hello, world!");

    another_function();

}

fn another_function() {
println!("Another function."); // 別の関数
}
Rust において関数定義は、fn キーワードで始まり、関数名の後に丸かっこの組が続きます。 波かっこが、コンパイラに関数本体の開始と終了の位置を伝えます。

定義した関数は、名前に丸かっこの組を続けることで呼び出すことができます。 another_function 関数がプログラム内で定義されているので、main 関数内から呼び出すことができるわけです。 ソースコード中で another_function を main 関数の後に定義していることに注目してください; 勿論、main 関数の前に定義することもできます。コンパイラは、関数がどこで定義されているかは気にしません。 どこかで定義されていることのみ気にします。

functions という名前の新しいバイナリ生成プロジェクトを始めて、関数についてさらに深く探究していきましょう。 another_function の例を src/main.rs ファイルに配置して、走らせてください。 以下のような出力が得られるはずです:

\$ cargo run
Compiling functions v0.1.0 (file:///projects/functions)
Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
Running `target/debug/functions`
Hello, world!
Another function.
行出力は、main 関数内に書かれた順序で実行されています。最初に"Hello, world"メッセージが出て、 それから another_function が呼ばれて、こちらのメッセージが出力されています。

関数の引数
関数は、引数を持つようにも定義できます。引数とは、関数シグニチャの一部になる特別な変数のことです。 関数に引数があると、引数の位置に実際の値を与えることができます。技術的にはこの実際の値は 実引数と呼ばれますが、普段の会話では、仮引数("parameter")と実引数("argument")を関数定義の変数と関数呼び出し時に渡す実際の値、 両方の意味に区別なく使います(訳注: 日本語では、特別区別する意図がない限り、どちらも単に引数と呼ぶことが多いでしょう)。

以下の書き直した another_function では、Rust の仮引数がどのようなものかを示しています:

ファイル名: src/main.rs

fn main() {
another_function(5);
}

fn another_function(x: i32) {
println!("The value of x is: {}", x); // x の値は{}です
}
このプログラムを走らせてみてください; 以下のような出力が得られるはずです:

\$ cargo run
Compiling functions v0.1.0 (file:///projects/functions)
Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
Running `target/debug/functions`
The value of x is: 5
another_function の宣言には、x という名前の仮引数があります。x の型は、 i32 と指定されています。値 5 が another_function に渡されると、println!マクロにより、 フォーマット文字列中の 1 組の波かっこがあった位置に値 5 が出力されます。

関数シグニチャにおいて、各仮引数の型を宣言しなければなりません。これは、Rust の設計において、 意図的な判断です: 関数定義で型注釈が必要不可欠ということは、コンパイラがその意図するところを推し量るのに、 プログラマがコードの他の箇所で使用する必要がないということを意味します。

関数に複数の仮引数を持たせたいときは、仮引数定義をカンマで区切ってください。 こんな感じです:

ファイル名: src/main.rs

fn main() {
another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
println!("The value of x is: {}", x);
println!("The value of y is: {}", y);
}
この例では、2 引数の関数を生成しています。そして、引数はどちらも i32 型です。それからこの関数は、 仮引数の値を両方出力します。関数引数は、全てが同じ型である必要はありません。今回は、 偶然同じになっただけです。

このコードを走らせてみましょう。今、function プロジェクトの src/main.rs ファイルに記載されているプログラムを先ほどの例と置き換えて、 cargo run で走らせてください:

\$ cargo run
Compiling functions v0.1.0 (file:///projects/functions)
Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
x に対して値 5、y に対して値 6 を渡して関数を呼び出したので、この二つの文字列は、 この値で出力されました。

関数本体は、文と式を含む
関数本体は、文が並び、最後に式を置くか文を置くという形で形成されます。現在までには、 式で終わらない関数だけを見てきたわけですが、式が文の一部になっているものなら見かけましたね。Rust は、式指向言語なので、 これは理解しておくべき重要な差異になります。他の言語にこの差異はありませんので、文と式がなんなのかと、 その違いが関数本体にどんな影響を与えるかを見ていきましょう。

実のところ、もう文と式は使っています。文とは、なんらかの動作をして値を返さない命令です。 式は結果値に評価されます。ちょっと例を眺めてみましょう。

let キーワードを使用して変数を生成し、値を代入することは文になります。 リスト 3-1 で let y = 6;は文です。

ファイル名: src/main.rs

fn main() {
let y = 6;
}
リスト 3-1: 1 文を含む main 関数宣言

関数定義も文になります。つまり、先の例は全体としても文になるわけです。

文は値を返しません。故に、let 文を他の変数に代入することはできません。 以下のコードではそれを試みていますが、エラーになります:

ファイル名: src/main.rs

fn main() {
let x = (let y = 6);
}
このプログラムを実行すると、以下のようなエラーが出るでしょう:

\$ cargo run
Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
(エラー: 式を予期しましたが、文が見つかりました (`let`))
--> src/main.rs:2:14
|
2 | let x = (let y = 6);
| ^^^
|
= note: variable declaration using `let` is a statement
(注釈: `let`を使う変数宣言は、文です)
この let y = 6 という文は値を返さないので、x に束縛するものがないわけです。これは、 C や Ruby などの言語とは異なる動作です。C や Ruby では、代入は代入値を返します。これらの言語では、 x = y = 6 と書いて、x も y も値 6 になるようにできるのですが、Rust においては、 そうは問屋が卸さないわけです。

式は何かに評価され、これからあなたが書く Rust コードの多くを構成します。 簡単な数学演算(5 + 6 など)を思い浮かべましょう。この例は、値 11 に評価される式です。式は文の一部になりえます: リスト 3-1 において、let y = 6 という文の 6 は値 6 に評価される式です。関数呼び出しも式です。マクロ呼び出しも式です。 新しいスコープを作る際に使用するブロック({})も式です:

ファイル名: src/main.rs

fn main() {
let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);

}
以下の式:

{
let x = 3;
x + 1
}
は今回の場合、4 に評価されるブロックです。その値が、let 文の一部として y に束縛されます。 今まで見かけてきた行と異なり、文末にセミコロンがついていない x + 1 の行に気をつけてください。 式は終端にセミコロンを含みません。式の終端にセミコロンを付けたら、文に変えてしまいます。そして、文は値を返しません。 次に関数の戻り値や式を見ていく際にこのことを肝に銘じておいてください。

戻り値のある関数
関数は、それを呼び出したコードに値を返すことができます。戻り値に名前を付けはしませんが、 矢印(->)の後に型を書いて確かに宣言します。Rust では、関数の戻り値は、関数本体ブロックの最後の式の値と同義です。 return キーワードで関数から早期リターンし、値を指定することもできますが、多くの関数は最後の式を暗黙的に返します。 こちらが、値を返す関数の例です:

ファイル名: src/main.rs

fn five() -> i32 {
5
}

fn main() {
let x = five();

    println!("The value of x is: {}", x);

}
five 関数内には、関数呼び出しもマクロ呼び出しも、let 文でさえ存在しません。数字の 5 が単独であるだけです。 これは、Rust において、完璧に問題ない関数です。関数の戻り値型が-> i32 と指定されていることにも注目してください。 このコードを実行してみましょう; 出力はこんな感じになるはずです:

\$ cargo run
Compiling functions v0.1.0 (file:///projects/functions)
Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
Running `target/debug/functions`
The value of x is: 5
five 内の 5 が関数の戻り値です。だから、戻り値型が i32 なのです。これについてもっと深く考察しましょう。 重要な箇所は 2 つあります: まず、let x = five()という行は、関数の戻り値を使って変数を初期化していることを示しています。 関数 five は 5 を返すので、この行は以下のように書くのと同義です:

let x = 5;
2 番目に、five 関数は仮引数をもたず、戻り値型を定義していますが、関数本体はセミコロンなしの 5 単独です。 なぜなら、これが返したい値になる式だからです。

もう一つ別の例を見ましょう:

ファイル名: src/main.rs

fn main() {
let x = plus_one(5);

    println!("The value of x is: {}", x);

}

fn plus_one(x: i32) -> i32 {
x + 1
}
このコードを走らせると、The value of x is: 6 と出力されるでしょう。しかし、 x + 1 を含む行の終端にセミコロンを付けて、式から文に変えたら、エラーになるでしょう:

ファイル名: src/main.rs

fn main() {
let x = plus_one(5);

    println!("The value of x is: {}", x);

}

fn plus_one(x: i32) -> i32 {
x + 1;
}
このコードを実行すると、以下のようにエラーが出ます:

error[E0308]: mismatched types
(型が合いません)
--> src/main.rs:7:28
|
7 | fn plus*one(x: i32) -> i32 {
| ************\_\_\_\_************^
8 | | x + 1;
| | - help: consider removing this semicolon
9 | | }
| |*^ expected i32, found ()
| (i32 を予期したのに、()型が見つかりました)
|
= note: expected type `i32`
found type `()`
メインのエラーメッセージである「型が合いません」でこのコードの根本的な問題が明らかになるでしょう。 関数 plus_one の定義では、i32 型を返すと言っているのに、文は値に評価されないからです。このことは、 ()、つまり空のタプルとして表現されています。それゆえに、何も戻り値がなく、これが関数定義と矛盾するので、 結果としてエラーになるわけです。この出力内で、コンパイラは問題を修正する手助けになりそうなメッセージも出していますね: セミコロンを削除するよう提言しています。そして、そうすれば、エラーは直るわけです。
