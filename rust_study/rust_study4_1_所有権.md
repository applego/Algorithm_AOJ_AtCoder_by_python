The Rust Programming Language 日本語版
まえがき
導入

1. 事始め
   1.1. インストール
   1.2. Hello, World!
   1.3. Hello, Cargo!
2. 数当てゲームをプログラムする
3. 一般的なプログラミングの概念
   3.1. 変数と可変性
   3.2. データ型
   3.3. 関数
   3.4. コメント
   3.5. フロー制御
4. 所有権を理解する
   4.1. 所有権とは？
   4.2. 参照と借用
   4.3. スライス型
5. 構造体を使用して関係のあるデータを構造化する
   5.1. 構造体を定義し、インスタンス化する
   5.2. 構造体を使ったプログラム例
   5.3. メソッド記法
6. Enum とパターンマッチング
   6.1. Enum を定義する
   6.2. match フロー制御演算子
   6.3. if let で簡潔なフロー制御
7. 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する
   7.1. パッケージとクレート
   7.2. モジュールを定義して、スコープとプライバシーを制御する
   7.3. モジュールツリーの要素を示すためのパス
   7.4. use キーワードでパスをスコープに持ち込む
   7.5. モジュールを複数のファイルに分割する
8. 一般的なコレクション
   8.1. ベクタで一連の値を保持する
   8.2. 文字列で UTF-8 でエンコードされたテキストを保持する
   8.3. キーとそれに紐づいた値をハッシュマップに格納する
9. エラー処理
   9.1. panic!で回復不能なエラー
   9.2. Result で回復可能なエラー
   9.3. panic!すべきかするまいか
10. ジェネリック型、トレイト、ライフタイム
    10.1. ジェネリックなデータ型
    10.2. トレイト：共通の振る舞いを定義する
    10.3. ライフタイムで参照を検証する
11. 自動テストを書く
    11.1. テストの記述法
    11.2. テストの実行のされ方を制御する
    11.3. テストの体系化
12. 入出力プロジェクト：コマンドラインプログラムを構築する
    12.1. コマンドライン引数を受け付ける
    12.2. ファイルを読み込む
    12.3. リファクタリンクしてモジュール性とエラー処理を向上させる
    12.4. テスト駆動開発でライブラリの機能を開発する
    12.5. 環境変数を取り扱う
    12.6. 標準出力ではなく標準エラーにエラーメッセージを書き込む
13. 関数型言語の機能：イテレータとクロージャ
    13.1. クロージャ：環境をキャプチャできる匿名関数
    13.2. 一連の要素をイテレータで処理する
    13.3. 入出力プロジェクトを改善する
    13.4. パフォーマンス比較：ループ VS イテレータ
14. Cargo と Crates.io についてより詳しく
    14.1. リリースプロファイルでビルドをカスタマイズする
    14.2. Crates.io にクレートを公開する
    14.3. Cargo のワークスペース
    14.4. cargo install で Crates.io からバイナリをインストールする
    14.5. 独自のコマンドで Cargo を拡張する
15. スマートポインタ
    15.1. ヒープのデータを指す Box を使用する
    15.2. Deref トレイトでスマートポインタを普通の参照のように扱う
    15.3. Drop トレイトで片付け時にコードを走らせる
    15.4. Rc は、参照カウント方式のスマートポインタ
    15.5. RefCell と内部可変性パターン
    15.6. 循環参照は、メモリをリークすることもある
16. 恐れるな！並行性
    16.1. スレッドを使用してコードを同時に走らせる
    16.2. メッセージ受け渡しを使ってスレッド間でデータを転送する
    16.3. 状態共有並行性
    16.4. Sync と Send トレイトで拡張可能な並行性
17. Rust のオブジェクト指向プログラミング機能
    17.1. オブジェクト指向言語の特徴
    17.2. トレイトオブジェクトで異なる型の値を許容する
    17.3. オブジェクト指向デザインパターンを実装する
18. パターンとマッチング
    18.1. パターンが使用されることのある箇所全部
    18.2. 論駁可能性：パターンが合致しないかどうか
    18.3. パターン記法
19. 高度な機能
    19.1. Unsafe Rust
    19.2. 高度なトレイト
    19.3. 高度な型
    19.4. 高度な関数とクロージャ
    19.5. マクロ
20. 最後のプロジェクト：マルチスレッドの Web サーバを構築する
    20.1. シングルスレッドの Web サーバを構築する
    20.2. シングルスレッドサーバをマルチスレッド化する
    20.3. 正常なシャットダウンと片付け
21. 付録
    21.1. 付録 A：キーワード
    21.2. 付録 B：演算子と記号
    21.3. 付録 C：導出可能なトレイト
    21.4. 付録 D：便利な開発ツール
    21.5. 付録 E：Edition
    21.6. 付録 F：本の翻訳
    21.7. 付録 G：Rust の作られ方と“Nightly Rust”

The Rust Programming Language 日本語版
所有権とは？
Rust の中心的な機能は、所有権です。この機能は、説明するのは簡単なのですが、言語の残りの機能全てにかかるほど 深い裏の意味を含んでいるのです。

全てのプログラムは、実行中にコンピュータのメモリの使用方法を管理する必要があります。プログラムが動作するにつれて、 定期的に使用されていないメモリを検索するガベージコレクションを持つ言語もありますが、他の言語では、 プログラマが明示的にメモリを確保したり、解放したりしなければなりません。Rust では第 3 の選択肢を取っています: メモリは、コンパイラがコンパイル時にチェックする一定の規則とともに所有権システムを通じて管理されています。 どの所有権機能も、実行中にプログラムの動作を遅くすることはありません。

所有権は多くのプログラマにとって新しい概念なので、慣れるまでに時間がかかります。 嬉しいことに、Rust と、所有権システムの規則の経験を積むと、より自然に安全かつ効率的なコードを構築できるようになります。 その調子でいきましょう！

所有権を理解した時、Rust を際立たせる機能の理解に対する強固な礎を得ることになるでしょう。この章では、 非常に一般的なデータ構造に着目した例を取り扱うことで所有権を学んでいきます: 文字列です。

スタックとヒープ
多くのプログラミング言語において、スタックとヒープについて考える機会はそう多くないでしょう。 しかし、Rust のようなシステムプログラミング言語においては、値がスタックに積まれるかヒープに置かれるかは、 言語の振る舞い方や、特定の決断を下す理由などに影響以上のものを与えるのです。 この章の後半でスタックとヒープを交えて所有権の一部が解説されるので、ここでちょっと予行演習をしておきましょう。

スタックもヒープも、実行時にコードが使用できるメモリの一部になりますが、異なる手段で構成されています。 スタックは、得た順番に値を並べ、逆の順で値を取り除いていきます。これは、 last in, first out(訳注: あえて日本語にするなら、「最後に入れたものが最初に出てくる」といったところでしょうか)と呼ばれます。 お皿の山を思い浮かべてください: お皿を追加する時には、山の一番上に置き、お皿が必要になったら、一番上から 1 枚を取り去りますよね。 途中や一番下に追加したり、取り除いたりすることもできません。データを追加することは、 スタックに push するといい、データを取り除くことは、スタックから pop すると表現します(訳注: 日本語では単純に英語をそのまま活用してプッシュ、ポップと表現するでしょう)。

データへのアクセス方法のおかげで、スタックは高速です: 新しいデータを置いたり、 データを取得する場所を探す必要が絶対にないわけです。というのも、その場所は常に一番上だからですね。 スタックを高速にする特性は他にもあり、それはスタック上のデータは全て既知の固定サイズでなければならないということです。

コンパイル時にサイズがわからなかったり、サイズが可変のデータについては、代わりにヒープに格納することができます。 ヒープは、もっとごちゃごちゃしています: ヒープにデータを置く時、あるサイズのスペースを求めます。 OS はヒープ上に十分な大きさの空の領域を見つけ、使用中にし、ポインタを返します。ポインタとは、その場所へのアドレスです。 この過程は、ヒープに領域を確保する(allocating on the heap)と呼ばれ、時としてそのフレーズを単に allocate するなどと省略したりします。 (訳注: こちらもこなれた日本語訳はないでしょう。allocate は「メモリを確保する」と訳したいところですが) スタックに値を積むことは、メモリ確保とは考えられません。ポインタは、既知の固定サイズなので、 スタックに保管することができますが、実データが必要になったら、ポインタを追いかける必要があります。

レストランで席を確保することを考えましょう。入店したら、グループの人数を告げ、 店員が全員座れる空いている席を探し、そこまで誘導します。もしグループの誰かが遅れて来るのなら、 着いた席の場所を尋ねてあなたを発見することができます。

ヒープへのデータアクセスは、スタックのデータへのアクセスよりも低速です。 ポインタを追って目的の場所に到達しなければならないからです。現代のプロセッサは、メモリをあちこち行き来しなければ、 より速くなります。似た例えを続けましょう。レストランで多くのテーブルから注文を受ける給仕人を考えましょう。最も効率的なのは、 次のテーブルに移らずに、一つのテーブルで全部の注文を受け付けてしまうことです。テーブル A で注文を受け、 それからテーブル B の注文、さらにまた A、それからまた B と渡り歩くのは、かなり低速な過程になってしまうでしょう。 同じ意味で、プロセッサは、 データが隔離されている(ヒープではそうなっている可能性がある)よりも近くにある(スタックではこうなる)ほうが、 仕事をうまくこなせるのです。ヒープに大きな領域を確保する行為も時間がかかることがあります。

コードが関数を呼び出すと、関数に渡された値(ヒープのデータへのポインタも含まれる可能性あり)と、 関数のローカル変数がスタックに載ります。関数の実行が終了すると、それらの値はスタックから取り除かれます。

どの部分のコードがどのヒープ上のデータを使用しているか把握すること、ヒープ上の重複するデータを最小化すること、 メモリ不足にならないようにヒープ上の未使用のデータを掃除することは全て、所有権が解決する問題です。 一度所有権を理解したら、あまり頻繁にスタックとヒープに関して考える必要はなくなるでしょうが、 ヒープデータを管理することが所有権の存在する理由だと知っていると、所有権がありのままで動作する理由を 説明するのに役立つこともあります。

所有権規則
まず、所有権のルールについて見ていきましょう。 この規則を具体化する例を扱っていく間もこれらのルールを肝に銘じておいてください:

Rust の各値は、所有者と呼ばれる変数と対応している。
いかなる時も所有者は一つである。
所有者がスコープから外れたら、値は破棄される。
変数スコープ
第 2 章で、Rust プログラムの例はすでに見ています。もう基本的な記法は通り過ぎたので、 fn main() {というコードはもう例に含みません。従って、例をなぞっているなら、 これからの例は main 関数に手動で入れ込まなければいけなくなるでしょう。結果的に、例は少々簡潔になり、 定型コードよりも具体的な詳細に集中しやすくなります。

所有権の最初の例として、何らかの変数のスコープについて見ていきましょう。スコープとは、 要素が有効になるプログラム内の範囲のことです。以下のような変数があるとしましょう:

let s = "hello";
変数 s は、文字列リテラルを参照し、ここでは、文字列の値はプログラムのテキストとしてハードコードされています。 この変数は、宣言された地点から、現在のスコープの終わりまで有効になります。リスト 4-1 には、 変数 s が有効な場所に関する注釈がコメントで付記されています。

{ // s は、ここでは有効ではない。まだ宣言されていない
let s = "hello"; // s は、ここから有効になる

    // sで作業をする

} // このスコープは終わり。もう s は有効ではない
リスト 4-1: 変数と有効なスコープ

言い換えると、ここまでに重要な点は二つあります:

s がスコープに入ると、有効になる
スコープを抜けるまで、有効なまま
ここで、スコープと変数が有効になる期間の関係は、他の言語に類似しています。さて、この理解のもとに、 String 型を導入して構築していきましょう。

String 型
所有権の規則を具体化するには、第 3 章の「データ型」節で講義したものよりも、より複雑なデータ型が必要になります。 以前講義した型は全てスタックに保管され、スコープが終わるとスタックから取り除かれますが、 ヒープに確保されるデータ型を観察して、 コンパイラがどうそのデータを掃除すべきタイミングを把握しているかを掘り下げていきたいと思います。

ここでは、例として String 型を使用し、String 型の所有権にまつわる部分に着目しましょう。 また、この観点は、標準ライブラリや自分で生成する他の複雑なデータ型にも適用されます。 String 型については、第 8 章でより深く議論します。

既に文字列リテラルは見かけましたね。文字列リテラルでは、文字列の値はプログラムにハードコードされます。 文字列リテラルは便利ですが、テキストを使いたいかもしれない場面全てに最適なわけではありません。一因は、 文字列リテラルが不変であることに起因します。別の原因は、コードを書く際に、全ての文字列値が判明するわけではないからです: 例えば、ユーザ入力を受け付け、それを保持したいとしたらどうでしょうか？このような場面用に、Rust には、 2 種類目の文字列型、String 型があります。この型はヒープにメモリを確保するので、 コンパイル時にはサイズが不明なテキストも保持することができるのです。from 関数を使用して、 文字列リテラルから String 型を生成できます。以下のように:

let s = String::from("hello");
この二重コロンは、string_from などの名前を使うのではなく、 String 型直下の from 関数を特定する働きをする演算子です。この記法について詳しくは、 第 5 章の「メソッド記法」節と、第 7 章の「モジュール定義」でモジュールを使った名前空間分けについて話をするときに議論します。

この種の文字列は、可変化することができます:

let mut s = String::from("hello");

s.push_str(", world!"); // push_str()関数は、リテラルを String に付け加える

println!("{}", s); // これは`hello, world!`と出力する
では、ここでの違いは何でしょうか？なぜ、String 型は可変化できるのに、リテラルはできないのでしょうか？ 違いは、これら二つの型がメモリを扱う方法にあります。

メモリと確保
文字列リテラルの場合、中身はコンパイル時に判明しているので、テキストは最終的なバイナリファイルに直接ハードコードされます。 このため、文字列リテラルは、高速で効率的になるのです。しかし、これらの特性は、 その文字列リテラルの不変性にのみ端を発するものです。残念なことに、コンパイル時にサイズが不明だったり、 プログラム実行に合わせてサイズが可変なテキスト片用に一塊のメモリをバイナリに確保しておくことは不可能です。

String 型では、可変かつ伸長可能なテキスト破片をサポートするために、コンパイル時には不明な量のメモリを ヒープに確保して内容を保持します。つまり:

メモリは、実行時に OS に要求される。
String 型を使用し終わったら、OS にこのメモリを返還する方法が必要である。
この最初の部分は、既にしています: String::from 関数を呼んだら、その実装が必要なメモリを要求するのです。 これは、プログラミング言語において、極めて普遍的です。

しかしながら、2 番目の部分は異なります。ガベージコレクタ(GC)付きの言語では、GC がこれ以上、 使用されないメモリを検知して片付けるため、プログラマは、そのことを考慮する必要はありません。 GC がないなら、メモリがもう使用されないことを見計らって、明示的に返還するコードを呼び出すのは、 プログラマの責任になります。ちょうど要求の際にしたようにですね。これを正確にすることは、 歴史的にも難しいプログラミング問題の一つであり続けています。もし、忘れていたら、メモリを無駄にします。 タイミングが早すぎたら、無効な変数を作ってしまいます。2 回解放してしまっても、バグになるわけです。 allocate と free は完璧に 1 対 1 対応にしなければならないのです。

Rust は、異なる道を歩んでいます: ひとたび、メモリを所有している変数がスコープを抜けたら、 メモリは自動的に返還されます。こちらの例は、 リスト 4-1 のスコープ例を文字列リテラルから String 型を使うものに変更したバージョンになります:

{
let s = String::from("hello"); // s はここから有効になる

    // sで作業をする

} // このスコープはここでおしまい。s は
// もう有効ではない
String 型が必要とするメモリを OS に返還することが自然な地点があります: s 変数がスコープを抜ける時です。 変数がスコープを抜ける時、Rust は特別な関数を呼んでくれます。この関数は、drop と呼ばれ、 ここに String 型の書き手はメモリを返還するコードを配置することができます。Rust は、閉じ波括弧で自動的に drop 関数を呼び出します。

注釈: C++では、要素の生存期間の終了地点でリソースを解放するこのパターンを時に、 RAII(Resource Aquisition Is Initialization: リソースの獲得は、初期化である)と呼んだりします。 Rust の drop 関数は、あなたが RAII パターンを使ったことがあれば、馴染み深いものでしょう。

このパターンは、Rust コードの書かれ方に甚大な影響をもたらします。現状は簡単そうに見えるかもしれませんが、 ヒープ上に確保されたデータを複数の変数に使用させるようなもっと複雑な場面では、コードの振る舞いは、 予期しないものになる可能性もあります。これから、そのような場面を掘り下げてみましょう。

変数とデータの相互作用法: ムーブ
Rust においては、複数の変数が同じデータに対して異なる手段で相互作用することができます。 整数を使用したリスト 4-2 の例を見てみましょう。

let x = 5;
let y = x;
リスト 4-2: 変数 x の整数値を y に代入する

もしかしたら、何をしているのか予想することができるでしょう: 「値 5 を x に束縛する; それから x の値をコピーして y に束縛する。」これで、 二つの変数(x と y)が存在し、両方、値は 5 になりました。これは確かに起こっている現象を説明しています。 なぜなら、整数は既知の固定サイズの単純な値で、これら二つの 5 という値は、スタックに積まれるからです。

では、String バージョンを見ていきましょう:

let s1 = String::from("hello");
let s2 = s1;
このコードは先ほどのコードに酷似していますので、動作方法も同じだと思い込んでしまうかもしれません: 要するに、2 行目で s1 の値をコピーし、s2 に束縛するということです。ところが、 これは全く起こることを言い当てていません。

図 4-1 を見て、ベールの下で String に何が起きているかを確かめてください。 String 型は、左側に示されているように、3 つの部品でできています: 文字列の中身を保持するメモリへのポインタと長さ、そして、許容量です。この種のデータは、スタックに保持されます。 右側には、中身を保持したヒープ上のメモリがあります。

メモリ上の文字列
図 4-1: s1 に束縛された"hello"という値を保持する String のメモリ上の表現

長さは、String 型の中身が現在使用しているメモリ量をバイトで表したものです。許容量は、 String 型が OS から受け取った全メモリ量をバイトで表したものです。長さと許容量の違いは問題になることですが、 この文脈では違うので、とりあえずは、許容量を無視しても構わないでしょう。

s1 を s2 に代入すると、String 型のデータがコピーされます。つまり、スタックにあるポインタ、長さ、 許容量をコピーするということです。ポインタが指すヒープ上のデータはコピーしません。言い換えると、 メモリ上のデータ表現は図 4-2 のようになるということです。

同じ値を指す s1 と s2
図 4-2: s1 のポインタ、長さ、許容量のコピーを保持する変数 s2 のメモリ上での表現

メモリ上の表現は、図 4-3 のようにはなりません。これは、 Rust が代わりにヒープデータもコピーするという選択をしていた場合のメモリ表現ですね。Rust がこれをしていたら、 ヒープ上のデータが大きい時に s2 = s1 という処理の実行時性能がとても悪くなっていた可能性があるでしょう。

2 箇所への s1 と s2
図 4-3: Rust がヒープデータもコピーしていた場合に s2 = s1 という処理が行なった可能性のあること

先ほど、変数がスコープを抜けたら、Rust は自動的に drop 関数を呼び出し、 その変数が使っていたヒープメモリを片付けると述べました。しかし、図 4-2 は、 両方のデータポインタが同じ場所を指していることを示しています。これは問題です: s2 と s1 がスコープを抜けたら、 両方とも同じメモリを解放しようとします。これは二重解放エラーとして知られ、以前触れたメモリ安全性上のバグの一つになります。 メモリを 2 回解放することは、memory corruption (訳注: メモリの崩壊。意図せぬメモリの書き換え) につながり、 セキュリティ上の脆弱性を生む可能性があります。

メモリ安全性を保証するために、Rust においてこの場面で起こることの詳細がもう一つあります。 確保されたメモリをコピーしようとする代わりに、コンパイラは、s1 が最早有効ではないと考え、 故に s1 がスコープを抜けた際に何も解放する必要がなくなるわけです。s2 の生成後に s1 を使用しようとしたら、 どうなるかを確認してみましょう。動かないでしょう:

let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
コンパイラが無効化された参照は使用させてくれないので、以下のようなエラーが出るでしょう:

error[E0382]: use of moved value: `s1`
(ムーブされた値の使用: `s1`)
--> src/main.rs:5:28
|
3 | let s2 = s1;
| -- value moved here
4 |
5 | println!("{}, world!", s1);
| ^^ value used here after move
| (ムーブ後にここで使用されています)
|
= note: move occurs because `s1` has type `std::string::String`, which does
not implement the `Copy` trait
(注釈: ムーブが起きたのは、`s1`が`std::string::String`という
`Copy`トレイトを実装していない型だからです)
他の言語を触っている間に"shallow copy"と"deep copy"という用語を耳にしたことがあるなら、 データのコピーなしにポインタと長さ、許容量をコピーするという概念は、shallow copy のように思えるかもしれません。 ですが、コンパイラは最初の変数をも無効化するので、shallow copy と呼ばれる代わりに、 ムーブとして知られているわけです。この例では、s1 は s2 にムーブされたと表現するでしょう。 以上より、実際に起きることを図 4-4 に示してみました。

s2 にムーブされた s1
図 4-4: s1 が無効化された後のメモリ表現

これにて一件落着です。s2 だけが有効なので、スコープを抜けたら、それだけがメモリを解放して、 終わりになります。

付け加えると、これにより暗示される設計上の選択があります: Rust では、 自動的にデータの"deep copy"が行われることは絶対にないわけです。それ故に、あらゆる自動コピーは、実行時性能の観点で言うと、 悪くないと考えてよいことになります。

変数とデータの相互作用法: クローン
仮に、スタック上のデータだけでなく、本当に String 型のヒープデータの deep copy が必要ならば、 clone と呼ばれるよくあるメソッドを使うことができます。メソッド記法については第 5 章で議論しますが、 メソッドは多くのプログラミング言語に見られる機能なので、以前に見かけたこともあるんじゃないでしょうか。

これは、clone メソッドの動作例です:

let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
これは問題なく動作し、図 4-3 で示した動作を明示的に生み出します。ここでは、 ヒープデータが実際にコピーされています。

clone メソッドの呼び出しを見かけたら、何らかの任意のコードが実行され、その実行コストは高いと把握できます。 何か違うことが起こっているなと見た目でわかるわけです。

スタックのみのデータ: コピー
まだ話題にしていない別の問題があります。 この整数を使用したコードは、一部をリスト 4-2 で示しましたが、うまく動作する有効なものです:

let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
ですが、このコードは一見、今学んだことと矛盾しているように見えます: clone メソッドの呼び出しがないのに、x は有効で、y にムーブされませんでした。

その理由は、整数のようなコンパイル時に既知のサイズを持つ型は、スタック上にすっぽり保持されるので、 実際の値をコピーするのも高速だからです。これは、変数 y を生成した後にも x を無効化したくなる理由がないことを意味します。 換言すると、ここでは、shallow copy と deep copy の違いがないことになり、 clone メソッドを呼び出しても、一般的な shallow copy 以上のことをしなくなり、 そのまま放置しておけるということです。

Rust には Copy トレイトと呼ばれる特別な注釈があり、 整数のようなスタックに保持される型に対して配置することができます(トレイトについては第 10 章でもっと詳しく話します)。 型が Copy トレイトに適合していれば、代入後も古い変数が使用可能になります。コンパイラは、 型やその一部分でも Drop トレイトを実装している場合、Copy トレイトによる注釈をさせてくれません。 型の値がスコープを外れた時に何か特別なことを起こす必要がある場合に、Copy 注釈を追加すると、コンパイルエラーが出ます。 型に Copy 注釈をつける方法について学ぶには、付録 C の「導出可能なトレイト」をご覧ください。

では、どの型が Copy なのでしょうか？ある型について、ドキュメントをチェックすればいいのですが、 一般規則として、単純なスカラー値の集合は何でも Copy であり、メモリ確保が必要だったり、 何らかの形態のリソースだったりするものは Copy ではありません。ここに Copy の型の一部を並べておきます。

あらゆる整数型。u32 など。
論理値型である bool。true と false という値がある。
あらゆる浮動小数点型、f64 など。
文字型である char。
タプル。ただ、Copy の型だけを含む場合。例えば、(i32, i32)は Copy だが、 (i32, String)は違う。
所有権と関数
意味論的に、関数に値を渡すことと、値を変数に代入することは似ています。関数に変数を渡すと、 代入のようにムーブやコピーされます。リスト 4-3 は変数がスコープに入ったり、 抜けたりする地点について注釈してある例です。

ファイル名: src/main.rs

fn main() {
let s = String::from("hello"); // s がスコープに入る

    takes_ownership(s);             // sの値が関数にムーブされ...
                                    // ... ここではもう有効ではない

    let x = 5;                      // xがスコープに入る

    makes_copy(x);                  // xも関数にムーブされるが、
                                    // i32はCopyなので、この後にxを使っても
                                    // 大丈夫

} // ここで x がスコープを抜け、s もスコープを抜ける。ただし、s の値はムーブされているので、何も特別なことは起こらない。
//

fn takes_ownership(some_string: String) { // some_string がスコープに入る。
println!("{}", some_string);
} // ここで some_string がスコープを抜け、`drop`が呼ばれる。後ろ盾してたメモリが解放される。
//

fn makes_copy(some_integer: i32) { // some_integer がスコープに入る
println!("{}", some_integer);
} // ここで some_integer がスコープを抜ける。何も特別なことはない。
リスト 4-3: 所有権とスコープが注釈された関数群

takes_ownership の呼び出し後に s を呼び出そうとすると、コンパイラは、コンパイルエラーを投げるでしょう。 これらの静的チェックにより、ミスを犯さないでいられます。s や x を使用するコードを main に追加してみて、 どこで使えて、そして、所有権規則により、どこで使えないかを確認してください。

戻り値とスコープ
値を返すことでも、所有権は移動します。リスト 4-4 は、リスト 4-3 と似た注釈のついた例です。

ファイル名: src/main.rs

fn main() {
let s1 = gives_ownership(); // gives_ownership は、戻り値を s1 に
// ムーブする

    let s2 = String::from("hello");     // s2がスコープに入る

    let s3 = takes_and_gives_back(s2);  // s2はtakes_and_gives_backにムーブされ
                                        // 戻り値もs3にムーブされる

} // ここで、s3 はスコープを抜け、ドロップされる。s2 もスコープを抜けるが、ムーブされているので、
// 何も起きない。s1 もスコープを抜け、ドロップされる。

fn gives_ownership() -> String { // gives_ownership は、戻り値を
// 呼び出した関数にムーブする

    let some_string = String::from("hello"); // some_stringがスコープに入る

    some_string                              // some_stringが返され、呼び出し元関数に
                                             // ムーブされる

}

// takes_and_gives_back は、String を一つ受け取り、返す。
fn takes_and_gives_back(a_string: String) -> String { // a_string がスコープに入る。

    a_string  // a_stringが返され、呼び出し元関数にムーブされる

}
リスト 4-4: 戻り値の所有権を移動する

変数の所有権は、毎回同じパターンを辿っています: 別の変数に値を代入すると、ムーブされます。 ヒープにデータを含む変数がスコープを抜けると、データが別の変数に所有されるようムーブされていない限り、 drop により片付けられるでしょう。

所有権を取り、またその所有権を戻す、ということを全ての関数でしていたら、ちょっとめんどくさいですね。 関数に値は使わせるものの所有権を取らないようにさせるにはどうするべきでしょうか。 返したいと思うかもしれない関数本体で発生したあらゆるデータとともに、再利用したかったら、渡されたものをまた返さなきゃいけないのは、 非常に煩わしいことです。

タプルで、複数の値を返すことは可能です。リスト 4-5 のようにですね。

ファイル名: src/main.rs

fn main() {
let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    //'{}'の長さは、{}です
    println!("The length of '{}' is {}.", s2, len);

}

fn calculate_length(s: String) -> (String, usize) {
let length = s.len(); // len()メソッドは、String の長さを返します

    (s, length)

}
リスト 4-5: 引数の所有権を返す

でも、これでは、大袈裟すぎますし、ありふれているはずの概念に対して、作業量が多すぎます。 私たちにとって幸運なことに、Rust にはこの概念に対する機能があり、参照と呼ばれます。
