肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する

大きなプログラムを書く時、そのすべてを頭の中に入れておくのは不可能になるため、コードのまとまりを良くすることが重要になります。 関係した機能をまとめ、異なる特徴を持つコードを分割することにより、特定の機能を実装しているコードを見つけたり、機能を変更したりするためにどこを探せば良いのかを明確にできます。

私達がこれまでに書いてきたプログラムは、一つのファイル内の一つのモジュール内にありました。 プロジェクトが大きくなるにつれて、これを複数のモジュールに、ついで複数のファイルに分割することで、プログラムを整理することができます。 パッケージは複数のバイナリクレートからなり、またライブラリクレートを 1 つもつこともできます。 パッケージが大きくなるにつれて、その一部を抜き出して分離したクレートにし、外部依存とするのもよいでしょう。 この章ではそれらのテクニックすべてを学びます。 相互に関係し合い、同時に成長するパッケージの集まりからなる巨大なプロジェクトには、 Cargo がワークスペースという機能を提供します。これは 14 章の Cargo ワークスペースで解説します。

機能をグループにまとめられることに加え、実装の詳細がカプセル化されることにより、コードをより高いレベルで再利用できるようになります： 手続きを実装し終えてしまえば、他のコードはそのコードの公開されたインターフェースを通じて、実装の詳細を知ることなくそのコードを呼び出すことができるのです。 コードをどう書くかによって、どの部分が他のコードにも使える公開のものになるのか、それとも自分だけが変更できる非公開のものになるのかが決定されます。 これもまた、記憶しておくべき細部を制限してくれる方法のひとつです。

関係する概念にスコープがあります： コードが記述されているネストされた文脈には、「スコープ内」として定義される名前の集合があります。 コードを読んだり書いたりコンパイルしたりする時には、プログラマーやコンパイラは特定の場所にある特定の名前が、変数・関数・構造体・enum・モジュール・定数・その他のどの要素を表すのか、そしてその要素は何を意味するのかを知る必要があります。 そこでスコープを作り、どの名前がスコープ内/スコープ外にあるのかを変更することができます。 同じ名前のものを 2 つ同じスコープ内に持つことはできません。そこで、名前の衝突を解決するための方法があります。

Rust には、どの詳細を公開するか、どの詳細を非公開にするか、どの名前がプログラムのそれぞれのスコープにあるか、といったコードのまとまりを保つためのたくさんの機能があります。 これらの機能は、まとめて「モジュールシステム」と呼ばれることがあり、以下のようなものが含まれます。

パッケージ: クレートをビルドし、テストし、共有することができる Cargo の機能
クレート: ライブラリか実行可能ファイルを生成する、木構造をしたモジュール群
モジュール と use: これを使うことで、パスの構成、スコープ、公開するか否かを決定できます
パス: 要素（例えば構造体や関数やモジュール）に名前をつける方法
この章では、これらの機能をすべて学び、これらがどう相互作用するかについて議論し、これらをどう使ってスコープを制御するのかについて説明します。 この章を読み終わる頃には、モジュールシステムをしっかりと理解し、熟練者のごとくスコープを扱うことができるようになっているでしょう！

The Rust Programming Language 日本語版
パッケージとクレート
最初に学ぶモジュールシステムの要素は、パッケージとクレートです。 クレートはバイナリかライブラリのどちらかです。 クレートルート (crate root) とは、Rust コンパイラの開始点となり、クレートのルートモジュールを作るソースファイルのことです（モジュールについて詳しくは「モジュールを定義して、スコープとプライバシーを制御する」のセクションで説明します）。 パッケージ はある機能群を提供する 1 つ以上のクレートです。 パッケージは Cargo.toml という、それらのクレートをどのようにビルドするかを説明するファイルを持っています。

パッケージが何を持ってよいかはいくつかのルールで決まっています。 パッケージは 0 個か 1 個のライブラリクレートを持っていないといけません。それ以上は駄目です。 バイナリクレートはいくらでも持って良いですが、少なくとも（ライブラリでもバイナリでも良いですが）1 つのクレートを持っていないといけません。

パッケージを作る時に何が起こるか見てみましょう。 まず、cargo new というコマンドを入力します：

$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
\$ ls my-project/src
main.rs
このコマンドを入力したとき、Cargo は Cargo.toml ファイルを作り、パッケージを作ってくれました。 Cargo.toml の中身を見ても、src/main.rs については何も書いてありません。これは、Cargo は src/main.rs が、パッケージと同じ名前を持つバイナリクレートのクレートルートであるという慣習に従っているためです。 同じように、Cargo はパッケージディレクトリに src/lib.rs が含まれていたら、パッケージにはパッケージと同じ名前のライブラリクレートが含まれており、src/lib.rs がそのクレートルートなのだと判断します。 Cargo はクレートルートファイルを rustc に渡し、ライブラリやバイナリをビルドします。

今、このパッケージには src/main.rs しか含まれておらず、つまりこのパッケージは my-project という名前のバイナリクレートのみを持っているということです。 もしパッケージが src/main.rs と src/lib.rs を持っていたら、クレートは 2 つになります：どちらもパッケージと同じ名前を持つ、ライブラリクレートとバイナリクレートです。 ファイルを src/bin ディレクトリに置くことで、パッケージは複数のバイナリクレートを持つことができます。それぞれのファイルが別々のバイナリクレートになります。

クレートは、関連した機能を一つのスコープにまとめることで、その機能が複数のプロジェクト間で共有しやすいようにします。 例えば、2 章で使った rand クレートは、乱数を生成する機能を提供します。 rand クレートを私達のプロジェクトのスコープに持ち込むことで、この機能を私達のプロジェクトで使うことができます。 rand クレートが提供する機能にはすべて、クレートの名前 rand を使ってアクセスできます。

クレートの機能をそれ自身のスコープの中に入れたままにしておくことは、ある機能が私達のクレートで定義されたのか rand クレートで定義されたのかを明確にし、名前の衝突を予防してくれます。 例えば、rand クレートは Rng という名前のトレイトを提供しています。 更に、私達のクレートで Rng という名前の struct を定義することもできます。 クレートの機能はそのスコープ内の名前空間に位置づけられているので、rand を依存先として追加しても、コンパイラは Rng という名前が何を意味するのかについて混乱することはないのです。 私達のクレートでは、私達の定義した struct Rng のことであり、rand クレートの Rng トレイトには rand::Rng でアクセスするというわけです。

では、モジュールシステムの話に移りましょう！

The Rust Programming Language 日本語版
モジュールを定義して、スコープとプライバシーを制御する
この節では、モジュールと、その他のモジュールシステムの要素 ――すなわち、要素に名前をつけるための パス 、パスをスコープに持ち込む use キーワード、要素を公開する pub キーワード―― について学びます。 また、as キーワード、外部パッケージ、glob 演算子についても話します。 とりあえず、今はモジュールに集中しましょう！

モジュール はクレート内のコードをグループ化し、可読性と再利用性を上げるのに役に立ちます。 モジュールは要素の プライバシー も制御できます。プライバシーとは、要素がコードの外側で使える (公開 public) のか、内部の実装の詳細であり外部では使えない (非公開 private) のかです。

例えば、レストランの機能を提供するライブラリクレートを書いてみましょう。 実際にレストランを実装することではなく、コードの関係性に注目したいので、関数にシグネチャをつけますが中身は空白のままにします。

レストラン業界では、レストランの一部を 接客部門 (front of house) といい、その他を 後方部門 (back of house) といいます。 接客部門とはお客さんがいるところです。接客係がお客様を席に案内し、給仕係が注文と支払いを受け付け、バーテンダーが飲み物を作ります。 後方部門とはシェフや料理人がキッチンで働き、皿洗い係が食器を片付け、マネージャが管理業務をする場所です。

私達のクレートを現実のレストランと同じような構造にするために、関数をネストしたモジュールにまとめましょう。 restaurant という名前の新しいライブラリを cargo new --lib restaurant と実行することで作成し、Listing 7-1 のコードを src/lib.rs に書き込み、モジュールと関数のシグネチャを定義してください。

ファイル名: src/lib.rs

mod front_of_house {
mod hosting {
fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }

}
Listing 7-1: front_of_house モジュールにその他のモジュールが含まれ、さらにそれらが関数を含んでいる

モジュールは、mod キーワードを書き、次にモジュールの名前（今回の場合、front_of_house）を指定することで定義されます。 モジュールの中には、今回だと hosting と serving のように、他のモジュールをおくこともできます。 モジュールにはその他の要素の定義も置くことができます。例えば、構造体、enum、定数、トレイト、そして（Listing 7-1 のように）関数です。

モジュールを使うことで、関連する定義を一つにまとめ、関連する理由を名前で示せます。 このコードを使うプログラマーは、定義を全部読むことなく、グループ単位でコードを読み進められるので、欲しい定義を見つけ出すのが簡単になるでしょう。 このコードに新しい機能を付け加えるプログラマーは、プログラムのまとまりを保つために、どこにその機能のコードを置けば良いのかがわかるでしょう。

以前、 src/main.rs と src/lib.rs はクレートルートと呼ばれていると言いました。 この名前のわけは、 モジュールツリー と呼ばれるクレートのモジュール構造の根っこ （ルート）にこれら 2 つのファイルの中身が crate というモジュールを形成するからです。

Listing 7-2 は、Listing 7-1 の構造のモジュールツリーを示しています。

crate
└── front_of_house
├── hosting
│ ├── add_to_waitlist
│ └── seat_at_table
└── serving
├── take_order
├── serve_order
└── take_payment
Listing 7-2: Listing 7-1 のコードのモジュールツリー

このツリーを見ると、どのモジュールがどのモジュールの中にネストしているのかがわかります（例えば、hosting は front_of_house の中にネストしています）。 また、いくつかのモジュールはお互いに 兄弟 の関係にある、つまり、同じモジュール内で定義されていることもわかります（例えば hosting と serving は front_of_house で定義されています）。 他にも、家族関係の比喩を使って、モジュール A がモジュール B の中に入っている時、A は B の 子 であるといい、B は A の 親 であるといいます。 モジュールツリー全体が、暗黙のうちに作られた crate というモジュールの下にあることにも注目してください。

モジュールツリーを見ていると、コンピュータのファイルシステムのディレクトリツリーを思い出すかもしれません。その喩えはとても適切です！ ファイルシステムのディレクトリのように、モジュールはコードをまとめるのに使われるのです。 そしてディレクトリからファイルを見つけるように、目的のモジュールを見つけ出す方法が必要になります。
