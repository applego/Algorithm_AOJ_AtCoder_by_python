The Rust Programming Language 日本語版
まえがき
導入

1. 事始め
   1.1. インストール
   1.2. Hello, World!
   1.3. Hello, Cargo!
2. 数当てゲームをプログラムする
3. 一般的なプログラミングの概念
   3.1. 変数と可変性
   3.2. データ型
   3.3. 関数
   3.4. コメント
   3.5. フロー制御
4. 所有権を理解する
   4.1. 所有権とは？
   4.2. 参照と借用
   4.3. スライス型
5. 構造体を使用して関係のあるデータを構造化する
   5.1. 構造体を定義し、インスタンス化する
   5.2. 構造体を使ったプログラム例
   5.3. メソッド記法
6. Enum とパターンマッチング
   6.1. Enum を定義する
   6.2. match フロー制御演算子
   6.3. if let で簡潔なフロー制御
7. 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する
   7.1. パッケージとクレート
   7.2. モジュールを定義して、スコープとプライバシーを制御する
   7.3. モジュールツリーの要素を示すためのパス
   7.4. use キーワードでパスをスコープに持ち込む
   7.5. モジュールを複数のファイルに分割する
8. 一般的なコレクション
   8.1. ベクタで一連の値を保持する
   8.2. 文字列で UTF-8 でエンコードされたテキストを保持する
   8.3. キーとそれに紐づいた値をハッシュマップに格納する
9. エラー処理
   9.1. panic!で回復不能なエラー
   9.2. Result で回復可能なエラー
   9.3. panic!すべきかするまいか
10. ジェネリック型、トレイト、ライフタイム
    10.1. ジェネリックなデータ型
    10.2. トレイト：共通の振る舞いを定義する
    10.3. ライフタイムで参照を検証する
11. 自動テストを書く
    11.1. テストの記述法
    11.2. テストの実行のされ方を制御する
    11.3. テストの体系化
12. 入出力プロジェクト：コマンドラインプログラムを構築する
    12.1. コマンドライン引数を受け付ける
    12.2. ファイルを読み込む
    12.3. リファクタリンクしてモジュール性とエラー処理を向上させる
    12.4. テスト駆動開発でライブラリの機能を開発する
    12.5. 環境変数を取り扱う
    12.6. 標準出力ではなく標準エラーにエラーメッセージを書き込む
13. 関数型言語の機能：イテレータとクロージャ
    13.1. クロージャ：環境をキャプチャできる匿名関数
    13.2. 一連の要素をイテレータで処理する
    13.3. 入出力プロジェクトを改善する
    13.4. パフォーマンス比較：ループ VS イテレータ
14. Cargo と Crates.io についてより詳しく
    14.1. リリースプロファイルでビルドをカスタマイズする
    14.2. Crates.io にクレートを公開する
    14.3. Cargo のワークスペース
    14.4. cargo install で Crates.io からバイナリをインストールする
    14.5. 独自のコマンドで Cargo を拡張する
15. スマートポインタ
    15.1. ヒープのデータを指す Box を使用する
    15.2. Deref トレイトでスマートポインタを普通の参照のように扱う
    15.3. Drop トレイトで片付け時にコードを走らせる
    15.4. Rc は、参照カウント方式のスマートポインタ
    15.5. RefCell と内部可変性パターン
    15.6. 循環参照は、メモリをリークすることもある
16. 恐れるな！並行性
    16.1. スレッドを使用してコードを同時に走らせる
    16.2. メッセージ受け渡しを使ってスレッド間でデータを転送する
    16.3. 状態共有並行性
    16.4. Sync と Send トレイトで拡張可能な並行性
17. Rust のオブジェクト指向プログラミング機能
    17.1. オブジェクト指向言語の特徴
    17.2. トレイトオブジェクトで異なる型の値を許容する
    17.3. オブジェクト指向デザインパターンを実装する
18. パターンとマッチング
    18.1. パターンが使用されることのある箇所全部
    18.2. 論駁可能性：パターンが合致しないかどうか
    18.3. パターン記法
19. 高度な機能
    19.1. Unsafe Rust
    19.2. 高度なトレイト
    19.3. 高度な型
    19.4. 高度な関数とクロージャ
    19.5. マクロ
20. 最後のプロジェクト：マルチスレッドの Web サーバを構築する
    20.1. シングルスレッドの Web サーバを構築する
    20.2. シングルスレッドサーバをマルチスレッド化する
    20.3. 正常なシャットダウンと片付け
21. 付録
    21.1. 付録 A：キーワード
    21.2. 付録 B：演算子と記号
    21.3. 付録 C：導出可能なトレイト
    21.4. 付録 D：便利な開発ツール
    21.5. 付録 E：Edition
    21.6. 付録 F：本の翻訳
    21.7. 付録 G：Rust の作られ方と“Nightly Rust”

The Rust Programming Language 日本語版
オブジェクト指向デザインパターンを実装する
ステートパターンは、オブジェクト指向デザインパターンの 1 つです。このパターンの肝は、 値が一連のステートオブジェクトで表されるなんらかの内部状態を持ち、 その内部の状態に基づいて値の振る舞いが変化するというものです。ステートオブジェクトは、 機能を共有します: Rust では、もちろん、オブジェクトと継承ではなく、構造体とトレイトを使用します。 各ステートオブジェクトは、自身の振る舞いと別の状態に変化すべき時を司ることに責任を持ちます。 ステートオブジェクトを保持する値は、状態ごとの異なる振る舞いや、いつ状態が移行するかについては何も知りません。

ステートパターンを使用することは、プログラムの業務用件が変わる時、状態を保持する値のコードや、 値を使用するコードを変更する必要はないことを意味します。ステートオブジェクトの 1 つのコードを更新して、 規則を変更したり、あるいはおそらくステートオブジェクトを追加する必要しかないのです。 ステートデザインパターンの例と、その Rust での使用方法を見ましょう。

ブログ記事のワークフローを少しずつ実装していきます。ブログの最終的な機能は以下のような感じになるでしょう:

ブログ記事は、空の草稿から始まる。
草稿ができたら、査読が要求される。
記事が承認されたら、公開される。
公開されたブログ記事だけが表示する内容を返すので、未承認の記事は、誤って公開されない。
それ以外の記事に対する変更は、効果を持つべきではありません。例えば、査読を要求する前にブログ記事の草稿を承認しようとしたら、 記事は、非公開の草稿のままになるべきです。

リスト 17-11 は、このワークフローをコードの形で示しています: これは、 blog というライブラリクレートに実装する API の使用例です。まだ blog クレートを実装していないので、 コンパイルはできません。

ファイル名: src/main.rs

extern crate blog;
use blog::Post;

fn main() {
let mut post = Post::new();

    // 今日はお昼にサラダを食べた
    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());

}
リスト 17-11: blog クレートに欲しい振る舞いをデモするコード

ユーザが Post::new で新しいブログ記事の草稿を作成できるようにしたいです。それから、 草稿状態の間にブログ記事にテキストを追加できるようにしたいです。承認前に記事の内容を即座に得ようとしたら、 記事はまだ草稿なので、何も起きるべきではありません。デモ目的でコードに assert_eq!を追加しました。 これに対する素晴らしい単体テストは、ブログ記事の草稿が content メソッドから空の文字列を返すことをアサートすることでしょうが、 この例に対してテストを書くつもりはありません。

次に、記事の査読を要求できるようにしたく、また査読を待機している間は content に空の文字列を返してほしいです。 記事が承認を受けたら、公開されるべきです。つまり、content を呼んだ時に記事のテキストが返されるということです。

クレートから相互作用している唯一の型は、Post だけであることに注意してください。 この型はステートパターンを使用し、記事がなり得る種々の状態を表す 3 つのステートオブジェクトのうちの 1 つになる値を保持します。 草稿、査読待ち、公開中です。1 つの状態から別の状態への変更は、Post 型内部で管理されます。 Post インスタンスのライブラリ使用者が呼び出すメソッドに呼応して状態は変化しますが、 状態の変化を直接管理する必要はありません。また、ユーザは、 査読前に記事を公開するなど状態を誤ることはありません。

Post を定義し、草稿状態で新しいインスタンスを生成する
ライブラリの実装に取り掛かりましょう！なんらかの内容を保持する公開の Post 構造体が必要なことはわかるので、 構造体の定義と、関連する公開の Post インスタンスを生成する new 関数から始めましょう。リスト 17-12 のようにですね。 また、非公開の State トレイトも作成します。それから、Post は state という非公開のフィールドに、 Option で Box<State>のトレイトオブジェクトを保持します。Option が必要な理由はすぐわかります。

ファイル名: src/lib.rs

pub struct Post {
state: Option<Box<State>>,
content: String,
}

impl Post {
pub fn new() -> Post {
Post {
state: Some(Box::new(Draft {})),
content: String::new(),
}
}
}

trait State {}

struct Draft {}

impl State for Draft {}
リスト 17-12: Post 構造体、新規 Post インスタンスを生成する new 関数、 State トレイト、Draft 構造体の定義

State トレイトは、異なる記事の状態で共有される振る舞いを定義し、Draft、PendingReview、Published 状態は全て、 State トレイトを実装します。今は、トレイトにメソッドは何もなく、Draft が記事の初期状態にしたい状態なので、 その状態だけを定義することから始めます。

新しい Post を作る時、state フィールドは、Box を保持する Some 値にセットします。 この Box が Draft 構造体の新しいインスタンスを指します。これにより、 新しい Post を作る度に、草稿から始まることが保証されます。Post の state フィールドは非公開なので、 Post を他の状態で作成する方法はないのです！Post::new 関数では、content フィールドを新しい空の String にセットしています。

記事の内容のテキストを格納する
リスト 17-11 は、add_text というメソッドを呼び出し、ブログ記事のテキスト内容に追加される&str を渡せるようになりたいことを示しました。 これを content フィールドを pub にして晒すのではなく、メソッドとして実装しています。 これは、後ほど content フィールドデータの読まれ方を制御するメソッドを実装できることを意味しています。 add_text メソッドは非常に素直なので、リスト 17-13 の実装を impl Post ブロックに追加しましょう:

ファイル名: src/lib.rs

impl Post {
// --snip--
pub fn add_text(&mut self, text: &str) {
self.content.push_str(text);
}
}
リスト 17-13: 記事の content にテキストを追加する add_text メソッドを実装する

add_text メソッドは、self への可変参照を取ります。というのも、add_text を呼び出した Post インスタンスを変更しているからです。 それから content の String に対して push_str を呼び出し、text 引数を渡して保存された content に追加しています。 この振る舞いは、記事の状態によらないので、ステートパターンの一部ではありません。add_text メソッドは、 state フィールドと全く相互作用しませんが、サポートしたい振る舞いの一部ではあります。

草稿の記事の内容は空であることを保証する
add_text を呼び出して記事に内容を追加した後でさえ、記事はまだ草稿状態なので、 それでも content メソッドには空の文字列スライスを返してほしいです。 リスト 17-11 の 8 行目で示したようにですね。とりあえず、この要求を実現する最も単純な方法で content メソッドを実装しましょう: 常に空の文字列スライスを返すことです。一旦、記事の状態を変更する能力を実装したら、公開できるように、 これを後ほど変更します。ここまで、記事は草稿状態にしかなり得ないので、記事の内容は常に空のはずです。 リスト 17-14 は、この仮の実装を表示しています:

ファイル名: src/lib.rs

impl Post {
// --snip--
pub fn content(&self) -> &str {
""
}
}
リスト 17-14: Post に常に空の文字列スライスを返す content の仮の実装を追加する

この追加された content メソッドとともに、リスト 17-11 の 8 行目までのコードは、想定通り動きます。

記事の査読を要求すると、状態が変化する
次に、記事の査読を要求する機能を追加する必要があり、これをすると、状態が Draft から PendingReview に変わるはずです。 リスト 17-15 はこのコードを示しています:

ファイル名: src/lib.rs

impl Post {
// --snip--
pub fn request_review(&mut self) {
if let Some(s) = self.state.take() {
self.state = Some(s.request_review())
}
}
}

trait State {
fn request_review(self: Box<Self>) -> Box<State>;
}

struct Draft {}

impl State for Draft {
fn request_review(self: Box<Self>) -> Box<State> {
Box::new(PendingReview {})
}
}

struct PendingReview {}

impl State for PendingReview {
fn request_review(self: Box<Self>) -> Box<State> {
self
}
}
リスト 17-15: Post と State トレイトに request_review メソッドを実装する

Post に self への可変参照を取る request_review という公開メソッドを与えます。それから、 Post の現在の状態に対して内部の request_review メソッドを呼び出し、 この 2 番目の request_review が現在の状態を消費し、新しい状態を返します。

State トレイトに request_review メソッドを追加しました; このトレイトを実装する型は全て、 これで request_review メソッドを実装する必要があります。メソッドの第 1 引数に self、&self、&mut self ではなく、 self: Box<Self>としていることに注意してください。この記法は、型を保持する Box に対して呼ばれた時のみ、 このメソッドが合法になることを意味しています。この記法は、Box<Self>の所有権を奪い、古い状態を無効化するので、 Post の状態値は、新しい状態に変形できます。

古い状態を消費するために、request_review メソッドは、状態値の所有権を奪う必要があります。 ここで Post の state フィールドの Option が問題になるのです: take メソッドを呼び出して、 state フィールドから Some 値を取り出し、その箇所に None を残します。なぜなら、Rust は、 構造体に未代入のフィールドを持たせてくれないからです。これにより、借用するのではなく、 Post の state 値をムーブすることができます。それから、記事の state 値をこの処理の結果にセットするのです。

self.state = self.state.request_review();のようなコードで直接 state 値の所有権を得るよう設定するのではなく、 一時的に None に state をセットする必要があります。これにより、新しい状態に変形した後に、 Post が古い state 値を使えないことが保証されるのです。

Draft の request_review メソッドは、新しい PendingReview 構造体の新しいボックスのインスタンスを返す必要があり、 これが、記事が査読待ちの時の状態を表します。PendingReview 構造体も request_review メソッドを実装しますが、 何も変形はしません。むしろ、自身を返します。というのも、既に PendingReview 状態にある記事の査読を要求したら、 PendingReview 状態に留まるべきだからです。

ようやくステートパターンの利点が見えてき始めました: state 値が何であれ、Post の request_review メソッドは同じです。 各状態は、独自の規則にのみ責任を持ちます。

Post の content メソッドを空の文字列スライスを返してそのままにします。 これで Post は PendingReview と Draft 状態になり得ますが、PendingReview 状態でも、 同じ振る舞いが欲しいです。もうリスト 17-11 は 11 行目まで動くようになりました！

content の振る舞いを変化させる approve メソッドを追加する
approve メソッドは、request_review メソッドと類似するでしょう: 状態が承認された時に、 現在の状態があるべきと言う値に state をセットします。リスト 17-16 のようにですね:

ファイル名: src/lib.rs

impl Post {
// --snip--
pub fn approve(&mut self) {
if let Some(s) = self.state.take() {
self.state = Some(s.approve())
}
}
}

trait State {
fn request_review(self: Box<Self>) -> Box<State>;
fn approve(self: Box<Self>) -> Box<State>;
}

struct Draft {}

impl State for Draft {
// --snip--
fn approve(self: Box<Self>) -> Box<State> {
self
}
}

struct PendingReview {}

impl State for PendingReview {
// --snip--
fn approve(self: Box<Self>) -> Box<State> {
Box::new(Published {})
}
}

struct Published {}

impl State for Published {
fn request_review(self: Box<Self>) -> Box<State> {
self
}

    fn approve(self: Box<Self>) -> Box<State> {
        self
    }

}
リスト 17-16: Post と State トレイトに approve メソッドを実装する

State トレイトに approve メソッドを追加し、Published 状態という State を実装する新しい構造体を追加します。

request_review のように、Draft に対して approve メソッドを呼び出したら、self を返すので、 何も効果はありません。PendingReview に対して approve を呼び出すと、 Published 構造体の新しいボックス化されたインスタンスを返します。Published 構造体は State トレイトを実装し、 request_review メソッドと approve メソッド両方に対して、自身を返します。 そのような場合に記事は、Published 状態に留まるべきだからです。

さて、Post の content メソッドを更新する必要が出てきました: 状態が Published なら、 記事の content フィールドの値を返したいのです; それ以外なら、空の文字列スライスを返したいです。 リスト 17-17 のようにですね:

ファイル名: src/lib.rs

impl Post {
// --snip--
pub fn content(&self) -> &str {
self.state.as_ref().unwrap().content(&self)
}
// --snip--
}
リスト 17-17: Post の content メソッドを更新して State の content メソッドに委譲する

目的は、これらの規則全てを State を実装する構造体の内部に押し留めることなので、state の値に対して content メソッドを呼び出し、 記事のインスタンス(要するに、self)を引数として渡します。そして、state 値の content メソッドを使用したことから返ってきた値を返します。

Option に対して as_ref メソッドを呼び出します。値の所有権ではなく、Option 内部の値への参照が欲しいからです。 state は Option<Box<State>>なので、as_ref を呼び出すと、Option<&Box<State>>が返ってきます。 as_ref を呼ばなければ、state を関数引数の借用した&self からムーブできないので、エラーになるでしょう。

さらに unwrap メソッドを呼び出し、これは絶対にパニックしないことがわかっています。何故なら、 Post のメソッドが、それらのメソッドが完了した際に state は常に Some 値を含んでいることを保証するからです。 これは、コンパイラには理解不能であるものの、 None 値が絶対にあり得ないとわかる第 9 章の「コンパイラよりも情報を握っている場合」節で語った一例です。

この時点で、&Box<State>に対して content を呼び出すと、参照外し型強制が&と Box に働くので、 究極的に content メソッドが State トレイトを実装する型に対して呼び出されることになります。 つまり、content を State トレイト定義に追加する必要があり、そこが現在の状態に応じてどの内容を返すべきかというロジックを配置する場所です。 リスト 17-18 のようにですね:

ファイル名: src/lib.rs

trait State {
// --snip--
fn content<'a>(&self, post: &'a Post) -> &'a str {
""
}
}

// --snip--
struct Published {}

impl State for Published {
// --snip--
fn content<'a>(&self, post: &'a Post) -> &'a str {
&post.content
}
}
リスト 17-18: State トレイトに content メソッドを追加する

空の文字列スライスを返すデフォルト実装を content メソッドに追加しています。これにより、 Draft と PendingReview 構造体に content を実装する必要はありません。Published 構造体は、 content メソッドをオーバーライドし、post.content の値を返します。

第 10 章で議論したように、このメソッドにはライフタイム注釈が必要なことに注意してください。 post への参照を引数として取り、その post の一部への参照を返しているので、 返却される参照のライフタイムは、post 引数のライフタイムに関連します。

出来上がりました。要するに、リスト 17-11 はもう動くようになったのです！ブログ記事ワークフローの規則でステートパターンを実装しました。 その規則に関連するロジックは、Post 中に散乱するのではなく、ステートオブジェクトに息づいています。

ステートパターンの代償
オブジェクト指向のステートパターンを実装して各状態の時に記事がなり得る異なる種類の振る舞いをカプセル化する能力が、 Rust にあることを示してきました。Post のメソッドは、種々の振る舞いについては何も知りません。 コードを体系化する仕方によれば、公開された記事が振る舞うことのある様々な方法を知るには、1 箇所のみを調べればいいのです: Published 構造体の State トレイトの実装です。

ステートパターンを使用しない対立的な実装を作ることになったら、代わりに Post のメソッドか、 あるいは記事の状態を確認し、それらの箇所(編注: Post のメソッドのことか)の振る舞いを変更する main コードでさえ、 match 式を使用したかもしれません。そうなると、複数個所を調べて記事が公開状態にあることの裏の意味全てを理解しなければならなくなります！ これは、追加した状態が増えれば、さらに上がるだけでしょう: 各 match 式には、別のアームが必要になるのです。

ステートパターンでは、Post のメソッドと Post を使用する箇所で、match 式が必要になることはなく、 新しい状態を追加するのにも、新しい構造体を追加し、その 1 つの構造体にトレイトメソッドを実装するだけでいいわけです。

ステートパターンを使用した実装は、拡張して機能を増やすことが容易です。 ステートパターンを使用するコードの管理の単純さを確認するために、以下の提言を試してみてください:

記事の状態を PendingReview から Draft に戻す reject メソッドを追加する。
状態が Published に変化させられる前に approve を 2 回呼び出す必要があるようにする。
記事が Draft 状態の時のみテキスト内容をユーザが追加できるようにする。 ヒント: ステートオブジェクトに内容について変わる可能性のあるものの責任を持たせつつも、 Post を変更することには責任を持たせない。
ステートパターンの欠点の 1 つは、状態が状態間の遷移を実装しているので、状態の一部が密に結合した状態になってしまうことです。 PendingReview と Published の間に、Scheduled のような別の状態を追加したら、 代わりに PendingReview のコードを Scheduled に遷移するように変更しなければならないでしょう。 状態が追加されても PendingReview を変更する必要がなければ、作業が減りますが、 そうすれば別のデザインパターンに切り替えることになるでしょう。

別の欠点は、ロジックの一部を重複させてしまうことです。重複を除くためには、 State トレイトの request_review と approve メソッドに self を返すデフォルト実装を試みる可能性があります; ですが、これはオブジェクト安全性を侵害するでしょう。というのも、具体的な self が一体なんなのかトレイトには知りようがないからです。 State をトレイトオブジェクトとして使用できるようにしたいので、メソッドにはオブジェクト安全になってもらう必要があるのです。

他の重複には、Post の request_review と approve メソッドの実装が似ていることが含まれます。 両メソッドは Option の state の値に対する同じメソッドの実装に委譲していて、state フィールドの新しい値を結果にセットします。 このパターンに従う Post のメソッドが多くあれば、マクロを定義して繰り返しを排除することも考慮する可能性があります(マクロについては付録 D を参照)。

オブジェクト指向言語で定義されている通り忠実にステートパターンを実装することで、 Rust の強みをできるだけ発揮していません。blog クレートに対して行える無効な状態と遷移をコンパイルエラーにできる変更に目を向けましょう。

状態と振る舞いを型としてコード化する
ステートパターンを再考して別の代償を得る方法をお見せします。状態と遷移を完全にカプセル化して、 外部のコードに知らせないようにするよりも、状態を異なる型にコード化します。結果的に、 Rust の型検査システムが、公開記事のみが許可される箇所で草稿記事の使用を試みることをコンパイルエラーを発して阻止します。

リスト 17-11 の main の最初の部分を考えましょう:

ファイル名: src/main.rs

fn main() {
let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

}
それでも、Post::new で草稿状態の新しい記事を生成することと記事の内容にテキストを追加する能力は可能にします。 しかし、空の文字列を返す草稿記事の content メソッドを保持する代わりに、草稿記事は、 content メソッドを全く持たないようにします。そうすると、草稿記事の内容を得ようとしたら、 メソッドが存在しないというコンパイルエラーになるでしょう。その結果、 誤ってプロダクションコードで草稿記事の内容を表示することが不可能になります。 そのようなコードは、コンパイルさえできないからです。リスト 17-19 は Post 構造体、DraftPost 構造体、 さらにメソッドの定義を示しています:

ファイル名: src/lib.rs

pub struct Post {
content: String,
}

pub struct DraftPost {
content: String,
}

impl Post {
pub fn new() -> DraftPost {
DraftPost {
content: String::new(),
}
}

    pub fn content(&self) -> &str {
        &self.content
    }

}

impl DraftPost {
pub fn add_text(&mut self, text: &str) {
self.content.push_str(text);
}
}
リスト 17-19: content メソッドのある Post と content メソッドのない DraftPost

Post と DraftPost 構造体どちらにもブログ記事のテキストを格納する非公開の content フィールドがあります。 状態のコード化を構造体の型に移動したので、この構造体は最早 state フィールドを持ちません。 Post は公開された記事を表し、content を返す content メソッドがあります。

それでも Post::new 関数はありますが、Post のインスタンスを返すのではなく、DraftPost のインスタンスを返します。 content は非公開であり、Post を返す関数も存在しないので、現状 Post のインスタンスを生成することは不可能です。

DraftPost 構造体には、以前のようにテキストを content に追加できるよう add_text メソッドがありますが、 DraftPost には content メソッドが定義されていないことに注目してください！ 従って、これでプログラムは、全ての記事が草稿記事から始まり、草稿記事は表示できる内容がないことを保証します。 この制限をかいくぐる試みは、全てコンパイルエラーに落ち着くでしょう。

遷移を異なる型への変形として実装する
では、どうやって公開された記事を得るのでしょうか？公開される前に草稿記事は査読され、 承認されなければならないという規則を強制したいです。査読待ち状態の記事は、それでも内容を表示するべきではありません。 別の構造体 PendingReviewPost を追加し、DraftPost に PendingReviewPost を返す request_review メソッドを定義し、 PendingReviewPost に Post を返す approve メソッドを定義してこれらの制限を実装しましょう。リスト 17-20 のようにですね:

ファイル名: src/lib.rs

impl DraftPost {
// --snip--

    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }

}

pub struct PendingReviewPost {
content: String,
}

impl PendingReviewPost {
pub fn approve(self) -> Post {
Post {
content: self.content,
}
}
}
リスト 17-20: DraftPost の request_review を呼び出すことで生成される PendingReviewPost と、 PendingReviewPost を公開された Post に変換する approve メソッド

request_review と approve メソッドは self の所有権を奪い、故に DraftPost と PendingReviewPost インスタンスを消費し、 それぞれ PendingReviewPost と公開された Post に変形します。このように、 DraftPost インスタンスに request_review を呼んだ後には、DraftPost インスタンスは生きながらえず、 以下同様です。PendingReviewPost 構造体には、content メソッドが定義されていないので、 DraftPost 同様に、その内容を読もうとするとコンパイルエラーに落ち着きます。 content メソッドが確かに定義された公開された Post インスタンスを得る唯一の方法が、 PendingReviewPost に対して approve を呼び出すことであり、PendingReviewPost を得る唯一の方法が、 DraftPost に request_review を呼び出すことなので、これでブログ記事のワークフローを型システムにコード化しました。

ですが、さらに main にも多少小さな変更を行わなければなりません。request_review と approve メソッドは、 呼ばれた構造体を変更するのではなく、新しいインスタンスを返すので、let post =というシャドーイング代入をもっと追加し、 返却されたインスタンスを保存する必要があります。また、草稿と査読待ち記事の内容を空の文字列でアサートすることも、 する必要もありません: 最早、その状態にある記事の内容を使用しようとするコードはコンパイル不可能だからです。 main の更新されたコードは、リスト 17-21 に示されています:

ファイル名: src/main.rs

extern crate blog;
use blog::Post;

fn main() {
let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());

}
リスト 17-21: ブログ記事ワークフローの新しい実装を使う main の変更

post を再代入するために main に行う必要のあった変更は、この実装がもう、 全くオブジェクト指向のステートパターンに沿っていないことを意味します: 状態間の変形は最早、Post 実装内に完全にカプセル化されていません。 ですが、型システムとコンパイル時に起きる型チェックのおかげでもう無効な状態があり得なくなりました。 これにより、未公開の記事の内容が表示されるなどの特定のバグが、プロダクションコードに移る前に発見されることが保証されます。

blog クレートに関してこの節の冒頭で触れた追加の要求に提言される作業をそのままリスト 17-20 の後に試してみて、 このバージョンのコードについてどう思うか確かめてください。この設計では、 既に作業の一部が達成されている可能性があることに注意してください。

Rust は、オブジェクト指向のデザインパターンを実装する能力があるものの、状態を型システムにコード化するなどの他のパターンも、 Rust では利用可能なことを確かめました。これらのパターンには、異なる代償があります。 あなたが、オブジェクト指向のパターンには非常に馴染み深い可能性があるものの、問題を再考して Rust の機能の強みを活かすと、 コンパイル時に一部のバグを回避できるなどの利益が得られることもあります。オブジェクト指向のパターンは、 オブジェクト指向言語にはない所有権などの特定の機能により Rust では、必ずしも最善の解決策ではないでしょう。

まとめ
この章読了後に、あなたが Rust はオブジェクト指向言語であると考えるかどうかに関わらず、 もうトレイトオブジェクトを使用して Rust でオブジェクト指向の機能の一部を得ることができると知っています。 ダイナミックディスパッチは、多少の実行時性能と引き換えにコードに柔軟性を齎もたらしてくれます。 この柔軟性を利用してコードのメンテナンス性に寄与するオブジェクト指向パターンを実装することができます。 Rust にはまた、オブジェクト指向言語にはない所有権などの他の機能もあります。オブジェクト指向パターンは、 必ずしも Rust の強みを活かす最善の方法にはなりませんが、利用可能な選択肢の 1 つではあります。

次は、パターンを見ます。パターンも多くの柔軟性を可能にする Rust の別の機能です。 本全体を通して僅かに見かけましたが、まだその全能力は目の当たりにしていません。さあ、行きましょう！

No definitions found
